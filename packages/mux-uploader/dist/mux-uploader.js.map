{
  "version": 3,
  "sources": ["../src/constants.ts", "../src/polyfills/index.ts", "../../../node_modules/@mux/upchunk/node_modules/global/window.js", "../../../node_modules/@mux/upchunk/node_modules/is-function/index.js", "../../../node_modules/@mux/upchunk/node_modules/parse-headers/parse-headers.js", "../../../node_modules/@mux/upchunk/node_modules/xtend/immutable.js", "../../../node_modules/@mux/upchunk/node_modules/xhr/index.js", "../../../node_modules/@mux/upchunk/node_modules/src/lib/misc.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/error-handler.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/global.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/warning-handler.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/warnings.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/event.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/dom-exception.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/event-wrapper.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/listener.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/listener-list.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/listener-list-map.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/event-target.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/event-attribute-handler.ts", "../../../node_modules/@mux/upchunk/node_modules/src/lib/legacy.ts", "../../../node_modules/@mux/upchunk/src/upchunk.ts", "../src/utils/element-utils.ts", "../src/mux-uploader-drop.ts", "../src/utils/progress.ts", "../src/mux-uploader-progress.ts", "../src/mux-uploader-status.ts", "../src/mux-uploader-retry.ts", "../src/mux-uploader-pause.ts", "../src/mux-uploader-file-select.ts", "../src/layouts/block.ts", "../src/mux-uploader.ts", "../src/mux-uploader-sr-text.ts", "../src/index.ts"],
  "sourcesContent": ["export type ProgressTypes = {\n  BAR: 'bar';\n  RADIAL: 'radial';\n  PERCENTAGE: 'percentage';\n};\n\nexport const ProgressTypes: ProgressTypes = {\n  BAR: 'bar',\n  RADIAL: 'radial',\n  PERCENTAGE: 'percentage',\n};\n", "/* eslint @typescript-eslint/no-empty-function: \"off\" */\n\nclass EventTarget {\n  addEventListener() {}\n  removeEventListener() {}\n  dispatchEvent(_event: Event) {\n    return true;\n  }\n}\n\n// @github/template-parts requires DocumentFragment to be available on globalThis for SSR\nif (typeof DocumentFragment === 'undefined') {\n  class DocumentFragment extends EventTarget {}\n  // @ts-ignore\n  globalThis.DocumentFragment = DocumentFragment;\n}\n\nclass HTMLElement extends EventTarget {}\nclass HTMLVideoElement extends EventTarget {}\n\nconst customElements: CustomElementRegistry = {\n  get(_name: string) {\n    return undefined;\n  },\n  define(_name, _constructor, _options) {},\n  getName(_constructor) {\n    return null;\n  },\n  upgrade(_root) {},\n  whenDefined(_name) {\n    return Promise.resolve(HTMLElement as unknown as CustomElementConstructor);\n  },\n};\n\nclass CustomEvent {\n  #detail;\n  get detail() {\n    return this.#detail;\n  }\n  constructor(_typeArg: string, eventInitDict: CustomEventInit = {}) {\n    // super(typeArg, eventInitDict);\n    this.#detail = eventInitDict?.detail;\n  }\n  initCustomEvent() {}\n}\n\nfunction createElement(_tagName: string, _options?: ElementCreationOptions): HTMLElement {\n  return new HTMLElement();\n}\n\nconst globalThisShim = {\n  document: {\n    createElement,\n  },\n  DocumentFragment,\n  customElements,\n  CustomEvent,\n  EventTarget,\n  HTMLElement,\n  HTMLVideoElement,\n};\n\n// const isServer = typeof window === 'undefined' || typeof globalThis.customElements === 'undefined';\n// const GlobalThis = isServer ? globalThisShim : globalThis;\n// const Document = isServer ? globalThisShim.document : globalThis.document;\n//\n// export { GlobalThis as globalThis, Document as document };\nconst isServer = typeof window === 'undefined' || typeof globalThis.customElements === 'undefined';\ntype GlobalThis = typeof globalThis;\nconst internalGlobalThis: GlobalThis = (isServer ? globalThisShim : globalThis) as GlobalThis;\nconst internalDocument: Document = (isServer ? globalThisShim.document : globalThis.document) as Document;\n\nexport { internalGlobalThis as globalThis, internalDocument as document };\n", "var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n", "module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  if (!fn) {\n    return false\n  }\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n", "var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n", "module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n", "\"use strict\";\nvar window = require(\"global/window\")\nvar isFunction = require(\"is-function\")\nvar parseHeaders = require(\"parse-headers\")\nvar xtend = require(\"xtend\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n", "/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nexport function assertType(\n    condition: boolean,\n    message: string,\n    ...args: any[]\n): asserts condition {\n    if (!condition) {\n        throw new TypeError(format(message, args))\n    }\n}\n\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nexport function format(message: string, args: any[]): string {\n    let i = 0\n    return message.replace(/%[os]/gu, () => anyToString(args[i++]))\n}\n\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nexport function anyToString(x: any): string {\n    if (typeof x !== \"object\" || x === null) {\n        return String(x)\n    }\n    return Object.prototype.toString.call(x)\n}\n", "import { anyToString, assertType } from \"./misc\"\n\ndeclare const console: any\ndeclare const dispatchEvent: any\ndeclare const ErrorEvent: any\ndeclare const process: any\n\nlet currentErrorHandler: setErrorHandler.ErrorHandler | undefined\n\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nexport function setErrorHandler(\n    value: setErrorHandler.ErrorHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The error handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentErrorHandler = value\n}\nexport namespace setErrorHandler {\n    /**\n     * The error handler.\n     * @param error The thrown error object.\n     */\n    export type ErrorHandler = (error: Error) => void\n}\n\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nexport function reportError(maybeError: unknown): void {\n    try {\n        const error =\n            maybeError instanceof Error\n                ? maybeError\n                : new Error(anyToString(maybeError))\n\n        // Call the user-defined error handler if exists.\n        if (currentErrorHandler) {\n            currentErrorHandler(error)\n            return\n        }\n\n        // Dispatch an `error` event if this is on a browser.\n        if (\n            typeof dispatchEvent === \"function\" &&\n            typeof ErrorEvent === \"function\"\n        ) {\n            dispatchEvent(\n                new ErrorEvent(\"error\", { error, message: error.message }),\n            )\n        }\n\n        // Emit an `uncaughtException` event if this is on Node.js.\n        //istanbul ignore else\n        else if (\n            typeof process !== \"undefined\" &&\n            typeof process.emit === \"function\"\n        ) {\n            process.emit(\"uncaughtException\", error)\n            return\n        }\n\n        // Otherwise, print the error.\n        console.error(error)\n    } catch {\n        // ignore.\n    }\n}\n", "declare const globalThis: any\ndeclare const window: any\ndeclare const self: any\ndeclare const global: any\n\n/**\n * The global object.\n */\n//istanbul ignore next\nexport const Global: any =\n    typeof window !== \"undefined\"\n        ? window\n        : typeof self !== \"undefined\"\n        ? self\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof globalThis !== \"undefined\"\n        ? globalThis\n        : undefined\n", "import { assertType } from \"./misc\"\n\ndeclare const console: any\n\nlet currentWarnHandler: setWarningHandler.WarningHandler | undefined\n\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nexport function setWarningHandler(\n    value: setWarningHandler.WarningHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The warning handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentWarnHandler = value\n}\nexport namespace setWarningHandler {\n    /**\n     * The warning information.\n     */\n    export interface Warning {\n        /**\n         * The code of this warning.\n         */\n        code: string\n        /**\n         * The message in English.\n         */\n        message: string\n        /**\n         * The arguments for replacing placeholders in the text.\n         */\n        args: any[]\n    }\n\n    /**\n     * The warning handler.\n     * @param warning The warning.\n     */\n    export type WarningHandler = (warning: Warning) => void\n}\n\n/**\n * The warning information.\n */\nexport class Warning<TArgs extends any[]> {\n    readonly code: string\n    readonly message: string\n\n    constructor(code: string, message: string) {\n        this.code = code\n        this.message = message\n    }\n\n    /**\n     * Report this warning.\n     * @param args The arguments of the warning.\n     */\n    warn(...args: TArgs): void {\n        try {\n            // Call the user-defined warning handler if exists.\n            if (currentWarnHandler) {\n                currentWarnHandler({ ...this, args })\n                return\n            }\n\n            // Otherwise, print the warning.\n            const stack = (new Error().stack ?? \"\").replace(\n                /^(?:.+?\\n){2}/gu,\n                \"\\n\",\n            )\n            console.warn(this.message, ...args, stack)\n        } catch {\n            // Ignore.\n        }\n    }\n}\n", "import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Warning } from \"./warning-handler\"\n\nexport const InitEventWasCalledWhileDispatching = new Warning<[]>(\n    \"W01\",\n    \"Unable to initialize event under dispatching.\",\n)\n\nexport const FalsyWasAssignedToCancelBubble = new Warning<[]>(\n    \"W02\",\n    \"Assigning any falsy value to 'cancelBubble' property has no effect.\",\n)\n\nexport const TruthyWasAssignedToReturnValue = new Warning<[]>(\n    \"W03\",\n    \"Assigning any truthy value to 'returnValue' property has no effect.\",\n)\n\nexport const NonCancelableEventWasCanceled = new Warning<[]>(\n    \"W04\",\n    \"Unable to preventDefault on non-cancelable events.\",\n)\n\nexport const CanceledInPassiveListener = new Warning<[]>(\n    \"W05\",\n    \"Unable to preventDefault inside passive event listener invocation.\",\n)\n\nexport const EventListenerWasDuplicated = new Warning<\n    [type: \"bubble\" | \"capture\", callback: EventTarget.EventListener<any, any>]\n>(\n    \"W06\",\n    \"An event listener wasn't added because it has been added already: %o, %o\",\n)\n\nexport const OptionWasIgnored = new Warning<\n    [name: \"passive\" | \"once\" | \"signal\"]\n>(\n    \"W07\",\n    \"The %o option value was abandoned because the event listener wasn't added as duplicated.\",\n)\n\nexport const InvalidEventListener = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {} | null | undefined]\n>(\n    \"W08\",\n    \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\",\n)\n\nexport const InvalidAttributeHandler = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {}]\n>(\"W09\", \"Event attribute handler must be a function: %o\")\n", "import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\nimport {\n    CanceledInPassiveListener,\n    FalsyWasAssignedToCancelBubble,\n    InitEventWasCalledWhileDispatching,\n    NonCancelableEventWasCanceled,\n    TruthyWasAssignedToReturnValue,\n} from \"./warnings\"\n\n/*eslint-disable class-methods-use-this */\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nexport class Event<TEventType extends string = string> {\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    static get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    static get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    static get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    static get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * Initialize this event instance.\n     * @param type The type of this event.\n     * @param eventInitDict Options to initialize.\n     * @see https://dom.spec.whatwg.org/#dom-event-event\n     */\n    constructor(type: TEventType, eventInitDict?: Event.EventInit) {\n        Object.defineProperty(this, \"isTrusted\", {\n            value: false,\n            enumerable: true,\n        })\n\n        const opts = eventInitDict ?? {}\n        internalDataMap.set(this, {\n            type: String(type),\n            bubbles: Boolean(opts.bubbles),\n            cancelable: Boolean(opts.cancelable),\n            composed: Boolean(opts.composed),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n            inPassiveListenerFlag: false,\n            dispatchFlag: false,\n            timeStamp: Date.now(),\n        })\n    }\n\n    /**\n     * The type of this event.\n     * @see https://dom.spec.whatwg.org/#dom-event-type\n     */\n    get type(): TEventType {\n        return $(this).type as TEventType\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    get target(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @deprecated Use the `target` property instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n     */\n    get srcElement(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    get currentTarget(): EventTarget | null {\n        return $(this).currentTarget\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * This doesn't support node tree.\n     * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n     */\n    composedPath(): EventTarget[] {\n        const currentTarget = $(this).currentTarget\n        if (currentTarget) {\n            return [currentTarget]\n        }\n        return []\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * The current event phase.\n     * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n     */\n    get eventPhase(): number {\n        return $(this).dispatchFlag ? 2 : 0\n    }\n\n    /**\n     * Stop event bubbling.\n     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n     */\n    stopPropagation(): void {\n        $(this).stopPropagationFlag = true\n    }\n\n    /**\n     * `true` if event bubbling was stopped.\n     * @deprecated\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    get cancelBubble(): boolean {\n        return $(this).stopPropagationFlag\n    }\n\n    /**\n     * Stop event bubbling if `true` is set.\n     * @deprecated Use the `stopPropagation()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    set cancelBubble(value: boolean) {\n        if (value) {\n            $(this).stopPropagationFlag = true\n        } else {\n            FalsyWasAssignedToCancelBubble.warn()\n        }\n    }\n\n    /**\n     * Stop event bubbling and subsequent event listener callings.\n     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n     */\n    stopImmediatePropagation(): void {\n        const data = $(this)\n        data.stopPropagationFlag = data.stopImmediatePropagationFlag = true\n    }\n\n    /**\n     * `true` if this event will bubble.\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n     */\n    get bubbles(): boolean {\n        return $(this).bubbles\n    }\n\n    /**\n     * `true` if this event can be canceled by the `preventDefault()` method.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n     */\n    get cancelable(): boolean {\n        return $(this).cancelable\n    }\n\n    /**\n     * `true` if the default behavior will act.\n     * @deprecated Use the `defaultPrevented` proeprty instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    get returnValue(): boolean {\n        return !$(this).canceledFlag\n    }\n\n    /**\n     * Cancel the default behavior if `false` is set.\n     * @deprecated Use the `preventDefault()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    set returnValue(value: boolean) {\n        if (!value) {\n            setCancelFlag($(this))\n        } else {\n            TruthyWasAssignedToReturnValue.warn()\n        }\n    }\n\n    /**\n     * Cancel the default behavior.\n     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n     */\n    preventDefault(): void {\n        setCancelFlag($(this))\n    }\n\n    /**\n     * `true` if the default behavior was canceled.\n     * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n     */\n    get defaultPrevented(): boolean {\n        return $(this).canceledFlag\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    get composed(): boolean {\n        return $(this).composed\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n     */\n    //istanbul ignore next\n    get isTrusted(): boolean {\n        return false\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n     */\n    get timeStamp(): number {\n        return $(this).timeStamp\n    }\n\n    /**\n     * @deprecated Don't use this method. The constructor did initialization.\n     */\n    initEvent(type: string, bubbles = false, cancelable = false) {\n        const data = $(this)\n        if (data.dispatchFlag) {\n            InitEventWasCalledWhileDispatching.warn()\n            return\n        }\n\n        internalDataMap.set(this, {\n            ...data,\n            type: String(type),\n            bubbles: Boolean(bubbles),\n            cancelable: Boolean(cancelable),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n        })\n    }\n}\n\n/*eslint-enable class-methods-use-this */\n\nexport namespace Event {\n    /**\n     * The options of the `Event` constructor.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventinit\n     */\n    export interface EventInit {\n        bubbles?: boolean\n        cancelable?: boolean\n        composed?: boolean\n    }\n}\n\nexport { $ as getEventInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NONE = 0\nconst CAPTURING_PHASE = 1\nconst AT_TARGET = 2\nconst BUBBLING_PHASE = 3\n\n/**\n * Private data.\n */\ninterface EventInternalData {\n    /**\n     * The value of `type` attribute.\n     */\n    readonly type: string\n    /**\n     * The value of `bubbles` attribute.\n     */\n    readonly bubbles: boolean\n    /**\n     * The value of `cancelable` attribute.\n     */\n    readonly cancelable: boolean\n    /**\n     * The value of `composed` attribute.\n     */\n    readonly composed: boolean\n    /**\n     * The value of `timeStamp` attribute.\n     */\n    readonly timeStamp: number\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    target: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    currentTarget: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-propagation-flag\n     */\n    stopPropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-immediate-propagation-flag\n     */\n    stopImmediatePropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#canceled-flag\n     */\n    canceledFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#in-passive-listener-flag\n     */\n    inPassiveListenerFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#dispatch-flag\n     */\n    dispatchFlag: boolean\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event: unknown, name = \"this\"): EventInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that Event constructor created, but got another one: %o\",\n        name,\n        event,\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data: EventInternalData) {\n    if (data.inPassiveListenerFlag) {\n        CanceledInPassiveListener.warn()\n        return\n    }\n    if (!data.cancelable) {\n        NonCancelableEventWasCanceled.warn()\n        return\n    }\n\n    data.canceledFlag = true\n}\n\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", { enumerable: true })\nObject.defineProperty(Event, \"CAPTURING_PHASE\", { enumerable: true })\nObject.defineProperty(Event, \"AT_TARGET\", { enumerable: true })\nObject.defineProperty(Event, \"BUBBLING_PHASE\", { enumerable: true })\nconst keys = Object.getOwnPropertyNames(Event.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(Event.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, Global.Event.prototype)\n}\n", "import { Global } from \"./global\"\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nexport function createInvalidStateError(message: string): Error {\n    if (Global.DOMException) {\n        return new Global.DOMException(message, \"InvalidStateError\")\n    }\n\n    if (DOMException == null) {\n        DOMException = class DOMException extends Error {\n            constructor(msg: string) {\n                super(msg)\n                if ((Error as any).captureStackTrace) {\n                    ;(Error as any).captureStackTrace(this, DOMException)\n                }\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get code() {\n                return 11\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get name() {\n                return \"InvalidStateError\"\n            }\n        }\n        Object.defineProperties(DOMException.prototype, {\n            code: { enumerable: true },\n            name: { enumerable: true },\n        })\n        defineErrorCodeProperties(DOMException)\n        defineErrorCodeProperties(DOMException.prototype)\n    }\n    return new DOMException(message)\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nlet DOMException: { new (message: string): Error } | undefined\n\nconst ErrorCodeMap = {\n    INDEX_SIZE_ERR: 1,\n    DOMSTRING_SIZE_ERR: 2,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    INVALID_CHARACTER_ERR: 5,\n    NO_DATA_ALLOWED_ERR: 6,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INUSE_ATTRIBUTE_ERR: 10,\n    INVALID_STATE_ERR: 11,\n    SYNTAX_ERR: 12,\n    INVALID_MODIFICATION_ERR: 13,\n    NAMESPACE_ERR: 14,\n    INVALID_ACCESS_ERR: 15,\n    VALIDATION_ERR: 16,\n    TYPE_MISMATCH_ERR: 17,\n    SECURITY_ERR: 18,\n    NETWORK_ERR: 19,\n    ABORT_ERR: 20,\n    URL_MISMATCH_ERR: 21,\n    QUOTA_EXCEEDED_ERR: 22,\n    TIMEOUT_ERR: 23,\n    INVALID_NODE_TYPE_ERR: 24,\n    DATA_CLONE_ERR: 25,\n}\ntype ErrorCodeMap = typeof ErrorCodeMap\n\nfunction defineErrorCodeProperties(obj: any): void {\n    const keys = Object.keys(ErrorCodeMap) as (keyof ErrorCodeMap)[]\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        const value = ErrorCodeMap[key]\n        Object.defineProperty(obj, key, {\n            get() {\n                return value\n            },\n            configurable: true,\n            enumerable: true,\n        })\n    }\n}\n", "import { Event } from \"./event\"\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nexport class EventWrapper<TEventType extends string> extends Event<TEventType> {\n    /**\n     * Wrap a given event object to control states.\n     * @param event The event-like object to wrap.\n     */\n    static wrap<T extends EventLike>(event: T): EventWrapperOf<T> {\n        return new (getWrapperClassOf(event))(event)\n    }\n\n    protected constructor(event: Event<TEventType>) {\n        super(event.type, {\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            composed: event.composed,\n        })\n\n        if (event.cancelBubble) {\n            super.stopPropagation()\n        }\n        if (event.defaultPrevented) {\n            super.preventDefault()\n        }\n\n        internalDataMap.set(this, { original: event })\n\n        // Define accessors\n        const keys = Object.keys(event)\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i]\n            if (!(key in this)) {\n                Object.defineProperty(\n                    this,\n                    key,\n                    defineRedirectDescriptor(event, key),\n                )\n            }\n        }\n    }\n\n    stopPropagation(): void {\n        super.stopPropagation()\n\n        const { original } = $(this)\n        if (\"stopPropagation\" in original) {\n            original.stopPropagation!()\n        }\n    }\n\n    get cancelBubble(): boolean {\n        return super.cancelBubble\n    }\n    set cancelBubble(value: boolean) {\n        super.cancelBubble = value\n\n        const { original } = $(this)\n        if (\"cancelBubble\" in original) {\n            original.cancelBubble = value\n        }\n    }\n\n    stopImmediatePropagation(): void {\n        super.stopImmediatePropagation()\n\n        const { original } = $(this)\n        if (\"stopImmediatePropagation\" in original) {\n            original.stopImmediatePropagation!()\n        }\n    }\n\n    get returnValue(): boolean {\n        return super.returnValue\n    }\n    set returnValue(value: boolean) {\n        super.returnValue = value\n\n        const { original } = $(this)\n        if (\"returnValue\" in original) {\n            original.returnValue = value\n        }\n    }\n\n    preventDefault(): void {\n        super.preventDefault()\n\n        const { original } = $(this)\n        if (\"preventDefault\" in original) {\n            original.preventDefault!()\n        }\n    }\n\n    get timeStamp(): number {\n        const { original } = $(this)\n        if (\"timeStamp\" in original) {\n            return original.timeStamp!\n        }\n        return super.timeStamp\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\ntype EventLike = { readonly type: string } & Partial<Event>\ntype EventWrapperOf<T extends EventLike> = Event<T[\"type\"]> &\n    Omit<T, keyof Event>\n\ninterface EventWrapperInternalData {\n    readonly original: EventLike\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventWrapperInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $(event: unknown): EventWrapperInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event,\n    )\n    return retv\n}\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap()\n\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper)\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    wrapperClassCache.set(Global.Event.prototype, EventWrapper)\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf<T extends EventLike>(\n    originalEvent: T,\n): { new (e: T): EventWrapperOf<T> } {\n    const prototype = Object.getPrototypeOf(originalEvent)\n    if (prototype == null) {\n        return EventWrapper as any\n    }\n\n    let wrapper: any = wrapperClassCache.get(prototype)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype)\n        wrapperClassCache.set(prototype, wrapper)\n    }\n\n    return wrapper\n}\n\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper: any, originalPrototype: any): any {\n    class CustomEventWrapper extends BaseEventWrapper {}\n\n    const keys = Object.keys(originalPrototype)\n    for (let i = 0; i < keys.length; ++i) {\n        Object.defineProperty(\n            CustomEventWrapper.prototype,\n            keys[i],\n            defineRedirectDescriptor(originalPrototype, keys[i]),\n        )\n    }\n\n    return CustomEventWrapper\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj: any, key: string): PropertyDescriptor {\n    const d = Object.getOwnPropertyDescriptor(obj, key)!\n    return {\n        get() {\n            const original: any = $(this).original\n            const value = original[key]\n            if (typeof value === \"function\") {\n                return value.bind(original)\n            }\n            return value\n        },\n        set(value: any) {\n            const original: any = $(this).original\n            original[key] = value\n        },\n        configurable: d.configurable,\n        enumerable: d.enumerable,\n    }\n}\n", "import { reportError } from \"./error-handler\"\nimport { Event } from \"./event\" // Used as only type, so no circular.\nimport { EventTarget } from \"./event-target\" // Used as only type, so no circular.\n\n/**\n * The event listener concept.\n * @see https://dom.spec.whatwg.org/#concept-event-listener\n */\nexport interface Listener {\n    /**\n     * The callback function.\n     */\n    readonly callback: Listener.Callback<any, any>\n    /**\n     * The flags of this listener.\n     * This is writable to add the removed flag.\n     */\n    flags: ListenerFlags\n    /**\n     * The `AbortSignal` to remove this listener.\n     */\n    readonly signal: Listener.AbortSignal | undefined\n    /**\n     * The `abort` event listener for the `signal`.\n     * To remove it from the `signal`.\n     */\n    readonly signalListener: (() => void) | undefined\n}\n\nexport namespace Listener {\n    export type Callback<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    export interface AbortSignal {\n        addEventListener(type: string, callback: Callback<any, Event>): void\n        removeEventListener(type: string, callback: Callback<any, Event>): void\n    }\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nexport function createListener(\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n    signalListener: (() => void) | undefined,\n): Listener {\n    return {\n        callback,\n        flags:\n            (capture ? ListenerFlags.Capture : 0) |\n            (passive ? ListenerFlags.Passive : 0) |\n            (once ? ListenerFlags.Once : 0),\n        signal,\n        signalListener,\n    }\n}\n\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nexport function setRemoved(listener: Listener): void {\n    listener.flags |= ListenerFlags.Removed\n}\n\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nexport function isCapture(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Capture) === ListenerFlags.Capture\n}\n\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nexport function isPassive(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Passive) === ListenerFlags.Passive\n}\n\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nexport function isOnce(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Once) === ListenerFlags.Once\n}\n\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nexport function isRemoved(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Removed) === ListenerFlags.Removed\n}\n\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nexport function invokeCallback(\n    { callback }: Listener,\n    target: EventTarget<any, any>,\n    event: Event<any>,\n): void {\n    try {\n        if (typeof callback === \"function\") {\n            callback.call(target, event)\n        } else if (typeof callback.handleEvent === \"function\") {\n            callback.handleEvent(event)\n        }\n    } catch (thrownError) {\n        reportError(thrownError)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The flags of listeners.\n */\nconst enum ListenerFlags {\n    Capture = 0x01,\n    Passive = 0x02,\n    Once = 0x04,\n    Removed = 0x08,\n}\n", "import { createListener, isCapture, Listener, setRemoved } from \"./listener\"\n\n/**\n * Information of an listener list.\n */\nexport interface ListenerList {\n    /**\n     * The callback function of the event attribute handler.\n     */\n    attrCallback: Listener.CallbackFunction<any, any> | undefined\n    /**\n     * The listener of the event attribute handler.\n     */\n    attrListener: Listener | undefined\n    /**\n     * `true` if the `dispatchEvent` method is traversing the current `listeners` array.\n     */\n    cow: boolean\n    /**\n     * The listeners.\n     * This is writable for copy-on-write.\n     */\n    listeners: Listener[]\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nexport function findIndexOfListener(\n    { listeners }: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): number {\n    for (let i = 0; i < listeners.length; ++i) {\n        if (\n            listeners[i].callback === callback &&\n            isCapture(listeners[i]) === capture\n        ) {\n            return i\n        }\n    }\n    return -1\n}\n\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nexport function addListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n): Listener {\n    let signalListener: (() => void) | undefined\n    if (signal) {\n        signalListener = removeListener.bind(null, list, callback, capture)\n        signal.addEventListener(\"abort\", signalListener)\n    }\n\n    const listener = createListener(\n        callback,\n        capture,\n        passive,\n        once,\n        signal,\n        signalListener,\n    )\n\n    if (list.cow) {\n        list.cow = false\n        list.listeners = [...list.listeners, listener]\n    } else {\n        list.listeners.push(listener)\n    }\n\n    return listener\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nexport function removeListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): boolean {\n    const index = findIndexOfListener(list, callback, capture)\n    if (index !== -1) {\n        return removeListenerAt(list, index)\n    }\n    return false\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nexport function removeListenerAt(\n    list: ListenerList,\n    index: number,\n    disableCow = false,\n): boolean {\n    const listener = list.listeners[index]\n\n    // Set the removed flag.\n    setRemoved(listener)\n\n    // Dispose the abort signal listener if exists.\n    if (listener.signal) {\n        listener.signal.removeEventListener(\"abort\", listener.signalListener!)\n    }\n\n    // Remove it from the array.\n    if (list.cow && !disableCow) {\n        list.cow = false\n        list.listeners = list.listeners.filter((_, i) => i !== index)\n        return false\n    }\n    list.listeners.splice(index, 1)\n    return true\n}\n", "import { ListenerList } from \"./listener-list\"\n\n/**\n * The map from event types to each listener list.\n */\nexport interface ListenerListMap {\n    [type: string]: ListenerList | undefined\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nexport function createListenerListMap(): ListenerListMap {\n    return Object.create(null)\n}\n\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nexport function ensureListenerList(\n    listenerMap: Record<string, ListenerList | undefined>,\n    type: string,\n): ListenerList {\n    return (listenerMap[type] ??= {\n        attrCallback: undefined,\n        attrListener: undefined,\n        cow: false,\n        listeners: [],\n    })\n}\n", "import { createInvalidStateError } from \"./dom-exception\"\nimport { Event, getEventInternalData } from \"./event\"\nimport { EventWrapper } from \"./event-wrapper\"\nimport { Global } from \"./global\"\nimport {\n    invokeCallback,\n    isCapture,\n    isOnce,\n    isPassive,\n    isRemoved,\n    Listener,\n} from \"./listener\"\nimport {\n    addListener,\n    findIndexOfListener,\n    removeListener,\n    removeListenerAt,\n} from \"./listener-list\"\nimport {\n    createListenerListMap,\n    ensureListenerList,\n    ListenerListMap,\n} from \"./listener-list-map\"\nimport { assertType, format } from \"./misc\"\nimport {\n    EventListenerWasDuplicated,\n    InvalidEventListener,\n    OptionWasIgnored,\n} from \"./warnings\"\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nexport class EventTarget<\n    TEventMap extends Record<string, Event> = Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n> {\n    /**\n     * Initialize this instance.\n     */\n    constructor() {\n        internalDataMap.set(this, createListenerListMap())\n    }\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    addEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.AddOptions,\n    ): void {\n        const listenerMap = $(this)\n        const {\n            callback,\n            capture,\n            once,\n            passive,\n            signal,\n            type,\n        } = normalizeAddOptions(type0, callback0, options0)\n        if (callback == null || signal?.aborted) {\n            return\n        }\n        const list = ensureListenerList(listenerMap, type)\n\n        // Find existing listener.\n        const i = findIndexOfListener(list, callback, capture)\n        if (i !== -1) {\n            warnDuplicate(list.listeners[i], passive, once, signal)\n            return\n        }\n\n        // Add the new listener.\n        addListener(list, callback, capture, passive, once, signal)\n    }\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    removeEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.Options,\n    ): void {\n        const listenerMap = $(this)\n        const { callback, capture, type } = normalizeOptions(\n            type0,\n            callback0,\n            options0,\n        )\n        const list = listenerMap[type]\n\n        if (callback != null && list) {\n            removeListener(list, callback, capture)\n        }\n    }\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent<T extends string & keyof TEventMap>(\n        event: EventTarget.EventData<TEventMap, TMode, T>,\n    ): boolean\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent(event: EventTarget.FallbackEvent<TMode>): boolean\n\n    // Implementation\n    dispatchEvent(\n        e:\n            | EventTarget.EventData<TEventMap, TMode, string>\n            | EventTarget.FallbackEvent<TMode>,\n    ): boolean {\n        const list = $(this)[String(e.type)]\n        if (list == null) {\n            return true\n        }\n\n        const event = e instanceof Event ? e : EventWrapper.wrap(e)\n        const eventData = getEventInternalData(event, \"event\")\n        if (eventData.dispatchFlag) {\n            throw createInvalidStateError(\"This event has been in dispatching.\")\n        }\n\n        eventData.dispatchFlag = true\n        eventData.target = eventData.currentTarget = this\n\n        if (!eventData.stopPropagationFlag) {\n            const { cow, listeners } = list\n\n            // Set copy-on-write flag.\n            list.cow = true\n\n            // Call listeners.\n            for (let i = 0; i < listeners.length; ++i) {\n                const listener = listeners[i]\n\n                // Skip if removed.\n                if (isRemoved(listener)) {\n                    continue\n                }\n\n                // Remove this listener if has the `once` flag.\n                if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n                    // Because this listener was removed, the next index is the\n                    // same as the current value.\n                    i -= 1\n                }\n\n                // Call this listener with the `passive` flag.\n                eventData.inPassiveListenerFlag = isPassive(listener)\n                invokeCallback(listener, this, event)\n                eventData.inPassiveListenerFlag = false\n\n                // Stop if the `event.stopImmediatePropagation()` method was called.\n                if (eventData.stopImmediatePropagationFlag) {\n                    break\n                }\n            }\n\n            // Restore copy-on-write flag.\n            if (!cow) {\n                list.cow = false\n            }\n        }\n\n        eventData.target = null\n        eventData.currentTarget = null\n        eventData.stopImmediatePropagationFlag = false\n        eventData.stopPropagationFlag = false\n        eventData.dispatchFlag = false\n\n        return !eventData.canceledFlag\n    }\n}\n\nexport namespace EventTarget {\n    /**\n     * The event listener.\n     */\n    export type EventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    /**\n     * The event listener function.\n     */\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    /**\n     * The event listener object.\n     * @see https://dom.spec.whatwg.org/#callbackdef-eventlistener\n     */\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    /**\n     * The common options for both `addEventListener` and `removeEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventlisteneroptions\n     */\n    export interface Options {\n        capture?: boolean\n    }\n\n    /**\n     * The options for the `addEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-addeventlisteneroptions\n     */\n    export interface AddOptions extends Options {\n        passive?: boolean\n        once?: boolean\n        signal?: AbortSignal | null | undefined\n    }\n\n    /**\n     * The abort signal.\n     * @see https://dom.spec.whatwg.org/#abortsignal\n     */\n    export interface AbortSignal extends EventTarget<{ abort: Event }> {\n        readonly aborted: boolean\n        onabort: CallbackFunction<this, Event> | null\n    }\n\n    /**\n     * The event data to dispatch in strict mode.\n     */\n    export type EventData<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\",\n        TEventType extends string\n    > = TMode extends \"strict\"\n        ? IsValidEventMap<TEventMap> extends true\n            ? ExplicitType<TEventType> &\n                  Omit<TEventMap[TEventType], keyof Event> &\n                  Partial<Omit<Event, \"type\">>\n            : never\n        : never\n\n    /**\n     * Define explicit `type` property if `T` is a string literal.\n     * Otherwise, never.\n     */\n    export type ExplicitType<T extends string> = string extends T\n        ? never\n        : { readonly type: T }\n\n    /**\n     * The event listener type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\"\n        ? EventListener<TEventTarget, Event> | null | undefined\n        : never\n\n    /**\n     * The event type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEvent<\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\" ? Event : never\n\n    /**\n     * Check if given event map is valid.\n     * It's valid if the keys of the event map are narrower than `string`.\n     */\n    export type IsValidEventMap<T> = string extends keyof T ? false : true\n}\n\nexport { $ as getEventTargetInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Internal data for EventTarget\n */\ntype EventTargetInternalData = ListenerListMap\n\n/**\n * Internal data.\n */\nconst internalDataMap = new WeakMap<any, EventTargetInternalData>()\n\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(target: any, name = \"this\"): EventTargetInternalData {\n    const retv = internalDataMap.get(target)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that EventTarget constructor created, but got another one: %o\",\n        name,\n        target,\n    )\n    return retv\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.AddOptions | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n    passive: boolean\n    once: boolean\n    signal: EventTarget.AbortSignal | undefined\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n            passive: Boolean(options.passive),\n            once: Boolean(options.once),\n            signal: options.signal ?? undefined,\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n        passive: false,\n        once: false,\n        signal: undefined,\n    }\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.Options | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n    }\n}\n\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback: any): void {\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" &&\n            callback !== null &&\n            typeof callback.handleEvent === \"function\")\n    ) {\n        return\n    }\n    if (callback == null || typeof callback === \"object\") {\n        InvalidEventListener.warn(callback)\n        return\n    }\n\n    throw new TypeError(format(InvalidEventListener.message, [callback]))\n}\n\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(\n    listener: Listener,\n    passive: boolean,\n    once: boolean,\n    signal: EventTarget.AbortSignal | undefined,\n): void {\n    EventListenerWasDuplicated.warn(\n        isCapture(listener) ? \"capture\" : \"bubble\",\n        listener.callback,\n    )\n\n    if (isPassive(listener) !== passive) {\n        OptionWasIgnored.warn(\"passive\")\n    }\n    if (isOnce(listener) !== once) {\n        OptionWasIgnored.warn(\"once\")\n    }\n    if (listener.signal !== signal) {\n        OptionWasIgnored.warn(\"signal\")\n    }\n}\n\n// Set enumerable\nconst keys = Object.getOwnPropertyNames(EventTarget.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(EventTarget.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof Global !== \"undefined\" &&\n    typeof Global.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype)\n}\n", "import { Event } from \"./event\"\nimport { EventTarget, getEventTargetInternalData } from \"./event-target\"\nimport { addListener, ListenerList, removeListener } from \"./listener-list\"\nimport { ensureListenerList } from \"./listener-list-map\"\nimport { InvalidAttributeHandler } from \"./warnings\"\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nexport function getEventAttributeValue<\n    TEventTarget extends EventTarget<any, any>,\n    TEvent extends Event\n>(\n    target: TEventTarget,\n    type: string,\n): EventTarget.CallbackFunction<TEventTarget, TEvent> | null {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    return listMap[type]?.attrCallback ?? null\n}\n\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nexport function setEventAttributeValue(\n    target: EventTarget<any, any>,\n    type: string,\n    callback: EventTarget.CallbackFunction<any, any> | null,\n): void {\n    if (callback != null && typeof callback !== \"function\") {\n        InvalidAttributeHandler.warn(callback)\n    }\n\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" && callback !== null)\n    ) {\n        upsertEventAttributeListener(target, type, callback)\n    } else {\n        removeEventAttributeListener(target, type)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener<\n    TEventTarget extends EventTarget<any, any>\n>(\n    target: TEventTarget,\n    type: string,\n    callback: EventTarget.CallbackFunction<TEventTarget, any>,\n): void {\n    const list = ensureListenerList(\n        getEventTargetInternalData(target, \"target\"),\n        String(type),\n    )\n    list.attrCallback = callback\n\n    if (list.attrListener == null) {\n        list.attrListener = addListener(\n            list,\n            defineEventAttributeCallback(list),\n            false,\n            false,\n            false,\n            undefined,\n        )\n    }\n}\n\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(\n    target: EventTarget<any, any>,\n    type: string,\n): void {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    const list = listMap[String(type)]\n    if (list && list.attrListener) {\n        removeListener(list, list.attrListener.callback, false)\n        list.attrCallback = list.attrListener = undefined\n    }\n}\n\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(\n    list: ListenerList,\n): EventTarget.CallbackFunction<any, any> {\n    return function (event) {\n        const callback = list.attrCallback\n        if (typeof callback === \"function\") {\n            callback.call(this, event)\n        }\n    }\n}\n", "import { Event } from \"./event\"\nimport {\n    getEventAttributeValue,\n    setEventAttributeValue,\n} from \"./event-attribute-handler\"\nimport { EventTarget } from \"./event-target\"\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineCustomEventTarget<\n    TEventMap extends Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n>(\n    ...types: (string & keyof TEventMap)[]\n): defineCustomEventTarget.CustomEventTargetConstructor<TEventMap, TMode> {\n    class CustomEventTarget extends EventTarget {}\n    for (let i = 0; i < types.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, types[i])\n    }\n\n    return CustomEventTarget as any\n}\n\nexport namespace defineCustomEventTarget {\n    /**\n     * The interface of CustomEventTarget constructor.\n     */\n    export type CustomEventTargetConstructor<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = {\n        /**\n         * Create a new instance.\n         */\n        new (): CustomEventTarget<TEventMap, TMode>\n        /**\n         * prototype object.\n         */\n        prototype: CustomEventTarget<TEventMap, TMode>\n    }\n\n    /**\n     * The interface of CustomEventTarget.\n     */\n    export type CustomEventTarget<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = EventTarget<TEventMap, TMode> &\n        defineEventAttribute.EventAttributes<any, TEventMap>\n}\n\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineEventAttribute<\n    TEventTarget extends EventTarget,\n    TEventType extends string,\n    TEventConstrucor extends typeof Event\n>(\n    target: TEventTarget,\n    type: TEventType,\n    _eventClass?: TEventConstrucor,\n): asserts target is TEventTarget &\n    defineEventAttribute.EventAttributes<\n        TEventTarget,\n        Record<TEventType, InstanceType<TEventConstrucor>>\n    > {\n    Object.defineProperty(target, `on${type}`, {\n        get() {\n            return getEventAttributeValue(this, type)\n        },\n        set(value) {\n            setEventAttributeValue(this, type, value)\n        },\n        configurable: true,\n        enumerable: true,\n    })\n}\n\nexport namespace defineEventAttribute {\n    /**\n     * Definition of event attributes.\n     */\n    export type EventAttributes<\n        TEventTarget extends EventTarget<any, any>,\n        TEventMap extends Record<string, Event>\n    > = {\n        [P in string &\n            keyof TEventMap as `on${P}`]: EventTarget.CallbackFunction<\n            TEventTarget,\n            TEventMap[P]\n        > | null\n    }\n}\n", "import { EventTarget, Event } from 'event-target-shim';\nimport xhr from 'xhr';\n// NOTE: Need duplicate imports for Typescript version compatibility reasons (CJP)\n/* tslint:disable-next-line no-duplicate-imports */\nimport type { XhrUrlConfig, XhrHeaders, XhrResponse } from 'xhr';\n\ntype XhrResponseLike = Partial<XhrResponse> & Pick<XhrResponse, 'statusCode'>;\n\nconst DEFAULT_CHUNK_SIZE = 30720;\nconst DEFAULT_MAX_CHUNK_SIZE = 512000; // in kB\nconst DEFAULT_MIN_CHUNK_SIZE = 256; // in kB\n\n// Predicate function that returns true if a given `chunkSize` is valid, otherwise false.\n// For `chunkSize` validity, we constrain by a min/max chunk size and conform to GCS:\n// \"The chunk size should be a multiple of 256 KiB (256 x 1024 bytes), unless it's the last\n// chunk that completes the upload.\" (See: https://cloud.google.com/storage/docs/performing-resumable-uploads)\nexport const isValidChunkSize = (\n  chunkSize: any,\n  {\n    minChunkSize = DEFAULT_MIN_CHUNK_SIZE,\n    maxChunkSize = DEFAULT_MAX_CHUNK_SIZE,\n  } = {}\n): chunkSize is number | null | undefined => {\n  return (\n    chunkSize == null ||\n    (typeof chunkSize === 'number' &&\n      chunkSize >= 256 &&\n      chunkSize % 256 === 0 &&\n      chunkSize >= minChunkSize &&\n      chunkSize <= maxChunkSize)\n  );\n};\n\n// Projection function that returns an error associated with invalid `chunkSize` values.\nexport const getChunkSizeError = (\n  chunkSize: any,\n  {\n    minChunkSize = DEFAULT_MIN_CHUNK_SIZE,\n    maxChunkSize = DEFAULT_MAX_CHUNK_SIZE,\n  } = {}\n) => {\n  return new TypeError(\n    `chunkSize ${chunkSize} must be a positive number in multiples of 256, between ${minChunkSize} and ${maxChunkSize}`\n  );\n};\n\nexport type ChunkedStreamIterableOptions = {\n  defaultChunkSize?: number;\n  minChunkSize?: number;\n  maxChunkSize?: number;\n};\n\nexport interface ChunkedIterable extends AsyncIterable<Blob> {\n  chunkSize: number;\n  readonly chunkByteSize: number;\n  readonly minChunkSize: number;\n  readonly maxChunkSize: number;\n  readonly error: Error | undefined;\n}\n\n// An Iterable that accepts a readableStream of binary data (Blob | Uint8Array) and provides\n// an asyncIterator which yields Blob values of the current chunkSize until done. Note that\n// chunkSize may change between iterations.\nexport class ChunkedStreamIterable implements ChunkedIterable {\n  protected _chunkSize: number | undefined;\n  protected defaultChunkSize: number;\n  protected _error: Error | undefined;\n  public readonly minChunkSize: number;\n  public readonly maxChunkSize: number;\n\n  constructor(\n    protected readableStream: ReadableStream<Uint8Array | Blob>,\n    options: ChunkedStreamIterableOptions = {}\n  ) {\n    if (!isValidChunkSize(options.defaultChunkSize, options)) {\n      throw getChunkSizeError(options.defaultChunkSize, options);\n    }\n    this.defaultChunkSize = options.defaultChunkSize ?? DEFAULT_CHUNK_SIZE;\n    this.minChunkSize = options.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n    this.maxChunkSize = options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  get chunkSize() {\n    return this._chunkSize ?? this.defaultChunkSize;\n  }\n\n  set chunkSize(value) {\n    if (!isValidChunkSize(value, this)) {\n      throw getChunkSizeError(value, this);\n    }\n    this._chunkSize = value;\n  }\n\n  get chunkByteSize() {\n    return this.chunkSize * 1024;\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Blob> {\n    let chunk;\n    const reader = this.readableStream.getReader();\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          // Last chunk, if any bits remain\n          if (chunk) {\n            const outgoingChunk = chunk;\n            chunk = undefined;\n            yield outgoingChunk;\n          }\n          break;\n        }\n\n        const normalizedBlobChunk =\n          value instanceof Uint8Array\n            ? new Blob([value], { type: 'application/octet-stream' })\n            : value;\n\n        chunk = chunk\n          ? new Blob([chunk, normalizedBlobChunk])\n          : normalizedBlobChunk;\n\n        // NOTE: Since we don't know how big the next chunk needs to be, we should\n        // just have a single blob that we \"peel away bytes from\" for each chunk\n        // as we iterate.\n        while (chunk) {\n          if (chunk.size === this.chunkByteSize) {\n            const outgoingChunk = chunk;\n            chunk = undefined;\n            yield outgoingChunk;\n            break;\n          } else if (chunk.size < this.chunkByteSize) {\n            break;\n          } else {\n            const outgoingChunk = chunk.slice(0, this.chunkByteSize);\n            chunk = chunk.slice(this.chunkByteSize);\n            yield outgoingChunk;\n          }\n        }\n      }\n    } catch (e) {\n      // There are edge case errors when attempting to read() from ReadableStream reader.\n      this._error = e;\n    } finally {\n      // Last chunk, if any bits remain\n      if (chunk) {\n        const outgoingChunk = chunk;\n        chunk = undefined;\n        yield outgoingChunk;\n      }\n      reader.releaseLock();\n      return;\n    }\n  }\n}\n\nexport class ChunkedFileIterable implements ChunkedIterable {\n  protected _chunkSize: number | undefined;\n  protected defaultChunkSize: number;\n  protected _error: Error | undefined;\n  public readonly minChunkSize: number;\n  public readonly maxChunkSize: number;\n\n  constructor(\n    protected file: File,\n    options: ChunkedStreamIterableOptions = {}\n  ) {\n    if (!isValidChunkSize(options.defaultChunkSize, options)) {\n      throw getChunkSizeError(options.defaultChunkSize, options);\n    }\n    this.defaultChunkSize = options.defaultChunkSize ?? DEFAULT_CHUNK_SIZE;\n    this.minChunkSize = options.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n    this.maxChunkSize = options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  get chunkSize() {\n    return this._chunkSize ?? this.defaultChunkSize;\n  }\n\n  set chunkSize(value) {\n    if (!isValidChunkSize(value, this)) {\n      throw getChunkSizeError(value, this);\n    }\n    this._chunkSize = value;\n  }\n\n  get chunkByteSize() {\n    return this.chunkSize * 1024;\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Blob> {\n    const reader = new FileReader();\n    let nextChunkRangeStart = 0;\n    /**\n     * Get portion of the file of x bytes corresponding to chunkSize\n     */\n    const getChunk = () => {\n      return new Promise<Blob | undefined>((resolve) => {\n        if (nextChunkRangeStart >= this.file.size) {\n          resolve(undefined);\n          return;\n        }\n        // We either want to slize a \"chunkByteSize-worth\" of the file or\n        // slice to the end of the file (if less than a \"chunkByteSize-worth\" is left)\n        const length = Math.min(\n          this.chunkByteSize,\n          this.file.size - nextChunkRangeStart\n        );\n        reader.onload = () => {\n          if (reader.result !== null) {\n            resolve(\n              new Blob([reader.result], {\n                type: 'application/octet-stream',\n              })\n            );\n          } else {\n            resolve(undefined);\n          }\n        };\n\n        reader.readAsArrayBuffer(\n          this.file.slice(nextChunkRangeStart, nextChunkRangeStart + length)\n        );\n      });\n    };\n    try {\n      while (true) {\n        const nextChunk = await getChunk();\n        if (!!nextChunk) {\n          nextChunkRangeStart += nextChunk.size;\n          yield nextChunk;\n        } else {\n          break;\n        }\n      }\n    } catch (e) {\n      this._error = e;\n    }\n  }\n}\n\nconst SUCCESSFUL_CHUNK_UPLOAD_CODES = [200, 201, 202, 204, 308];\nconst TEMPORARY_ERROR_CODES = [408, 502, 503, 504]; // These error codes imply a chunk may be retried\nconst RESUME_INCOMPLETE_CODES = [308];\n\ntype UploadPredOptions = {\n  retryCodes?: typeof TEMPORARY_ERROR_CODES;\n  attempts: number;\n  attemptCount: number;\n};\nconst isSuccessfulChunkUpload = (\n  res: XhrResponseLike | undefined,\n  _options?: any\n): res is XhrResponse =>\n  !!res && SUCCESSFUL_CHUNK_UPLOAD_CODES.includes(res.statusCode);\n\nconst isRetriableChunkUpload = (\n  res: XhrResponseLike | undefined,\n  { retryCodes = TEMPORARY_ERROR_CODES }: UploadPredOptions\n) => !res || retryCodes.includes(res.statusCode);\n\nconst isFailedChunkUpload = (\n  res: XhrResponseLike | undefined,\n  options: UploadPredOptions\n): res is XhrResponseLike => {\n  return (\n    options.attemptCount >= options.attempts ||\n    !(isSuccessfulChunkUpload(res) || isRetriableChunkUpload(res, options))\n  );\n};\n\n/**\n * Checks if an upload chunk was partially received (HTTP 308) and needs a retry.\n * Validates against the 'Range' header to ensure the full chunk was processed.\n */\nexport const isIncompleteChunkUploadNeedingRetry = (\n  res: XhrResponseLike | undefined,\n  _options?: any\n): res is XhrResponseLike => {\n  if (\n    !res ||\n    !RESUME_INCOMPLETE_CODES.includes(res.statusCode) ||\n    !res.headers?.['range']\n  ) {\n    return false;\n  }\n\n  const range = res.headers['range'].match(/bytes=(\\d+)-(\\d+)/);\n  if (!range) {\n    return false;\n  }\n\n  const endByte = parseInt(range[2], 10);\n  // NOTE: Since the endpoint may have been used previously and uploaded multiple chunks,\n  // only treat as an incomplete chunk upload if the end byte from the response header is\n  // less than the current chunk's end byte.\n  return endByte < _options.currentChunkEndByte;\n};\n\ntype EventName =\n  | 'attempt'\n  | 'attemptFailure'\n  | 'chunkSuccess'\n  | 'error'\n  | 'offline'\n  | 'online'\n  | 'progress'\n  | 'success';\n\n// NOTE: This and the EventTarget definition below could be more precise\n// by e.g. typing the detail of the CustomEvent per EventName.\ntype UpchunkEvent = CustomEvent & Event<EventName>;\n\ntype AllowedMethods = 'PUT' | 'POST' | 'PATCH';\n\nexport interface UpChunkOptions {\n  endpoint: string | ((file?: File) => Promise<string>);\n  file: File;\n  method?: AllowedMethods;\n  headers?: XhrHeaders | (() => XhrHeaders) | (() => Promise<XhrHeaders>);\n  maxFileSize?: number;\n  chunkSize?: number;\n  attempts?: number;\n  delayBeforeAttempt?: number;\n  retryCodes?: number[];\n  dynamicChunkSize?: boolean;\n  maxChunkSize?: number;\n  minChunkSize?: number;\n  useLargeFileWorkaround?: boolean;\n}\n\nexport class UpChunk {\n  public static createUpload(options: UpChunkOptions) {\n    return new UpChunk(options);\n  }\n\n  public endpoint: string | ((file?: File) => Promise<string>);\n  public file: File;\n  public headers: XhrHeaders | (() => XhrHeaders) | (() => Promise<XhrHeaders>);\n  public method: AllowedMethods;\n  public attempts: number;\n  public delayBeforeAttempt: number;\n  public retryCodes: number[];\n  public dynamicChunkSize: boolean;\n  protected chunkedIterable: ChunkedIterable;\n  protected chunkedIterator;\n\n  protected pendingChunk?: Blob;\n  private chunkCount: number;\n  private maxFileBytes: number;\n  private endpointValue: string;\n  private totalChunks: number;\n  private attemptCount: number;\n  private _offline: boolean;\n  private _paused: boolean;\n  private success: boolean;\n  private currentXhr?: XMLHttpRequest;\n  private lastChunkStart: Date;\n  private nextChunkRangeStart: number;\n\n  private eventTarget: EventTarget<Record<EventName, UpchunkEvent>>;\n\n  constructor(options: UpChunkOptions) {\n    this.eventTarget = new EventTarget();\n\n    this.endpoint = options.endpoint;\n    this.file = options.file;\n\n    this.headers = options.headers || ({} as XhrHeaders);\n    this.method = options.method || 'PUT';\n    this.attempts = options.attempts || 5;\n    this.delayBeforeAttempt = options.delayBeforeAttempt || 1;\n    this.retryCodes = options.retryCodes || TEMPORARY_ERROR_CODES;\n    this.dynamicChunkSize = options.dynamicChunkSize || false;\n\n    this.maxFileBytes = (options.maxFileSize || 0) * 1024;\n    this.chunkCount = 0;\n    this.attemptCount = 0;\n    // Initialize offline to the current offline state, where\n    // offline is false if\n    // 1. we're not running in the browser (aka window is undefined) -OR-\n    // 2. we're not online (as advertised by navigator.onLine)\n    this._offline = typeof window !== 'undefined' && !window.navigator.onLine;\n    this._paused = false;\n    this.success = false;\n    this.nextChunkRangeStart = 0;\n\n    if (options.useLargeFileWorkaround) {\n      const readableStreamErrorCallback = (event: CustomEvent) => {\n        // In this case, assume the error is a result of file reading via ReadableStream.\n        // Retry using ChunkedFileIterable, which reads the file into memory instead\n        // of a stream.\n        if (this.chunkedIterable.error) {\n          console.warn(\n            `Unable to read file of size ${this.file.size} bytes via a ReadableStream. Falling back to in-memory FileReader!`\n          );\n          event.stopImmediatePropagation();\n\n          // Re-set everything up with the fallback iterable and corresponding\n          // iterator\n          this.chunkedIterable = new ChunkedFileIterable(this.file, {\n            ...options,\n            defaultChunkSize: options.chunkSize,\n          });\n          this.chunkedIterator = this.chunkedIterable[Symbol.asyncIterator]();\n          this.getEndpoint()\n            .then(() => {\n              this.sendChunks();\n            })\n            .catch((e) => {\n              const message = e?.message ? `: ${e.message}` : '';\n              this.dispatch('error', {\n                message: `Failed to get endpoint${message}`,\n              });\n            });\n          this.off('error', readableStreamErrorCallback);\n        }\n      };\n      this.on('error', readableStreamErrorCallback);\n    }\n\n    // Types appear to be getting confused in env setup, using the overloaded NodeJS Blob definition, which uses NodeJS.ReadableStream instead\n    // of the DOM type definitions. For definitions, See consumers.d.ts vs. lib.dom.d.ts. (CJP)\n    this.chunkedIterable = new ChunkedStreamIterable(\n      this.file.stream() as unknown as ReadableStream<Uint8Array>,\n      { ...options, defaultChunkSize: options.chunkSize }\n    );\n    this.chunkedIterator = this.chunkedIterable[Symbol.asyncIterator]();\n\n    // NOTE: Since some of upchunk's properties defer \"source of truth\" to\n    // chunkedIterable, we need to do these after it's been created (CJP).\n    this.totalChunks = Math.ceil(this.file.size / this.chunkByteSize);\n    this.validateOptions();\n\n    this.getEndpoint()\n      .then(() => this.sendChunks())\n      .catch((e) => {\n        const message = e?.message ? `: ${e.message}` : '';\n        this.dispatch('error', {\n          message: `Failed to get endpoint${message}`,\n        });\n      });\n\n    // restart sync when back online\n    // trigger events when offline/back online\n    if (typeof window !== 'undefined') {\n      window.addEventListener('online', () => {\n        if (!this.offline) return;\n\n        this._offline = false;\n        this.dispatch('online');\n        this.sendChunks();\n      });\n\n      window.addEventListener('offline', () => {\n        if (this.offline) return;\n\n        this._offline = true;\n        this.dispatch('offline');\n      });\n    }\n  }\n\n  protected get maxChunkSize() {\n    return this.chunkedIterable?.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE;\n  }\n\n  protected get minChunkSize() {\n    return this.chunkedIterable?.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE;\n  }\n\n  public get chunkSize() {\n    return this.chunkedIterable?.chunkSize ?? DEFAULT_CHUNK_SIZE;\n  }\n\n  public set chunkSize(value) {\n    this.chunkedIterable.chunkSize = value;\n  }\n\n  public get chunkByteSize() {\n    return this.chunkedIterable.chunkByteSize;\n  }\n\n  public get totalChunkSize() {\n    return Math.ceil(this.file.size / this.chunkByteSize);\n  }\n\n  /**\n   * Subscribe to an event\n   */\n  public on(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.addEventListener(eventName, fn as EventListener);\n  }\n\n  /**\n   * Subscribe to an event once\n   */\n  public once(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.addEventListener(eventName, fn as EventListener, {\n      once: true,\n    });\n  }\n\n  /**\n   * Unsubscribe to an event\n   */\n  public off(eventName: EventName, fn: (event: CustomEvent) => void) {\n    this.eventTarget.removeEventListener(eventName, fn as EventListener);\n  }\n\n  public get offline() {\n    return this._offline;\n  }\n\n  public get paused() {\n    return this._paused;\n  }\n\n  public abort() {\n    this.pause();\n    this.currentXhr?.abort();\n  }\n\n  public pause() {\n    this._paused = true;\n  }\n\n  public resume() {\n    if (this._paused) {\n      this._paused = false;\n\n      this.sendChunks();\n    }\n  }\n\n  public get successfulPercentage() {\n    return this.nextChunkRangeStart / this.file.size;\n  }\n\n  /**\n   * Dispatch an event\n   */\n  private dispatch(eventName: EventName, detail?: any) {\n    const event: UpchunkEvent = new CustomEvent(eventName, {\n      detail,\n    }) as UpchunkEvent;\n\n    this.eventTarget.dispatchEvent(event);\n  }\n\n  /**\n   * Validate options and throw errors if expectations are violated.\n   */\n  private validateOptions() {\n    if (\n      !this.endpoint ||\n      (typeof this.endpoint !== 'function' && typeof this.endpoint !== 'string')\n    ) {\n      throw new TypeError(\n        'endpoint must be defined as a string or a function that returns a promise'\n      );\n    }\n    if (!(this.file instanceof File)) {\n      throw new TypeError('file must be a File object');\n    }\n    if (\n      this.headers &&\n      typeof this.headers !== 'function' &&\n      typeof this.headers !== 'object'\n    ) {\n      throw new TypeError(\n        'headers must be null, an object, or a function that returns an object or a promise'\n      );\n    }\n    if (\n      !isValidChunkSize(this.chunkSize, {\n        maxChunkSize: this.maxChunkSize,\n        minChunkSize: this.minChunkSize,\n      })\n    ) {\n      throw getChunkSizeError(this.chunkSize, {\n        maxChunkSize: this.maxChunkSize,\n        minChunkSize: this.minChunkSize,\n      });\n    }\n    if (\n      this.maxChunkSize &&\n      (typeof this.maxChunkSize !== 'number' ||\n        this.maxChunkSize < 256 ||\n        this.maxChunkSize % 256 !== 0 ||\n        this.maxChunkSize < this.chunkSize ||\n        this.maxChunkSize < this.minChunkSize)\n    ) {\n      throw new TypeError(\n        `maxChunkSize must be a positive number in multiples of 256, and larger than or equal to both ${this.minChunkSize} and ${this.chunkSize}`\n      );\n    }\n    if (\n      this.minChunkSize &&\n      (typeof this.minChunkSize !== 'number' ||\n        this.minChunkSize < 256 ||\n        this.minChunkSize % 256 !== 0 ||\n        this.minChunkSize > this.chunkSize ||\n        this.minChunkSize > this.maxChunkSize)\n    ) {\n      throw new TypeError(\n        `minChunkSize must be a positive number in multiples of 256, and smaller than ${this.chunkSize} and ${this.maxChunkSize}`\n      );\n    }\n    if (this.maxFileBytes > 0 && this.maxFileBytes < this.file.size) {\n      throw new Error(\n        `file size exceeds maximum (${this.file.size} > ${this.maxFileBytes})`\n      );\n    }\n    if (\n      this.attempts &&\n      (typeof this.attempts !== 'number' || this.attempts <= 0)\n    ) {\n      throw new TypeError('retries must be a positive number');\n    }\n    if (\n      this.delayBeforeAttempt &&\n      (typeof this.delayBeforeAttempt !== 'number' ||\n        this.delayBeforeAttempt < 0)\n    ) {\n      throw new TypeError('delayBeforeAttempt must be a positive number');\n    }\n  }\n\n  /**\n   * Endpoint can either be a URL or a function that returns a promise that resolves to a string.\n   */\n  private getEndpoint() {\n    if (typeof this.endpoint === 'string') {\n      this.endpointValue = this.endpoint;\n      return Promise.resolve(this.endpoint);\n    }\n\n    return this.endpoint(this.file).then((value) => {\n      this.endpointValue = value;\n      if (typeof value !== 'string') {\n        throw new TypeError('endpoint must return a string');\n      }\n      return this.endpointValue;\n    });\n  }\n\n  private xhrPromise(options: XhrUrlConfig): Promise<XhrResponse> {\n    const beforeSend = (xhrObject: XMLHttpRequest) => {\n      xhrObject.upload.onprogress = (event: ProgressEvent) => {\n        const remainingChunks = this.totalChunks - this.chunkCount;\n        const percentagePerChunk =\n          (this.file.size - this.nextChunkRangeStart) /\n          this.file.size /\n          remainingChunks;\n        const currentChunkProgress =\n          event.loaded / (event.total ?? this.chunkByteSize);\n        const chunkPercentage = currentChunkProgress * percentagePerChunk;\n        // NOTE: Since progress events are \"eager\" and do not (yet) have sufficient context\n        // to \"know\" if the request was e.g. successful, we need to \"recompute\"/\"rewind\"\n        // progress if/when we detect failures. See failedChunkUploadCb(), below. (CJP)\n        this.dispatch(\n          'progress',\n          Math.min((this.successfulPercentage + chunkPercentage) * 100, 100)\n        );\n      };\n    };\n\n    return new Promise((resolve, reject) => {\n      this.currentXhr = xhr({ ...options, beforeSend }, (err, resp) => {\n        this.currentXhr = undefined;\n        // NOTE: For at least some `err` cases, resp will still carry information. We may want to consider passing that on somehow\n        // in our Promise reject (or instead of err) (CJP)\n        // See: https://github.com/naugtur/xhr/blob/master/index.js#L93-L100\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve(resp);\n      });\n    });\n  }\n\n  /**\n   * Send chunk of the file with appropriate headers\n   */\n  protected async sendChunk(chunk: Blob) {\n    const rangeStart = this.nextChunkRangeStart;\n    const rangeEnd = rangeStart + chunk.size - 1;\n    const extraHeaders = await (typeof this.headers === 'function'\n      ? this.headers()\n      : this.headers);\n\n    const headers = {\n      ...extraHeaders,\n      'Content-Type': this.file.type,\n      'Content-Range': `bytes ${rangeStart}-${rangeEnd}/${this.file.size}`,\n    };\n\n    this.dispatch('attempt', {\n      chunkNumber: this.chunkCount,\n      totalChunks: this.totalChunks,\n      chunkSize: this.chunkSize,\n    });\n\n    return this.xhrPromise({\n      headers,\n      url: this.endpointValue,\n      method: this.method,\n      body: chunk,\n    });\n  }\n\n  protected async sendChunkWithRetries(chunk: Blob): Promise<boolean> {\n    // What to do if a chunk was successfully uploaded\n    const successfulChunkUploadCb = async (res: XhrResponse, _chunk?: Blob) => {\n      // Side effects\n      const lastChunkEnd = new Date();\n      const lastChunkInterval =\n        (lastChunkEnd.getTime() - this.lastChunkStart.getTime()) / 1000;\n\n      this.dispatch('chunkSuccess', {\n        chunk: this.chunkCount,\n        chunkSize: this.chunkSize,\n        attempts: this.attemptCount,\n        timeInterval: lastChunkInterval,\n        response: res,\n      });\n\n      this.attemptCount = 0;\n      this.chunkCount = (this.chunkCount ?? 0) + 1;\n      this.nextChunkRangeStart = this.nextChunkRangeStart + this.chunkByteSize;\n      if (this.dynamicChunkSize) {\n        let unevenChunkSize = this.chunkSize;\n        if (lastChunkInterval < 10) {\n          unevenChunkSize = Math.min(this.chunkSize * 2, this.maxChunkSize);\n        } else if (lastChunkInterval > 30) {\n          unevenChunkSize = Math.max(this.chunkSize / 2, this.minChunkSize);\n        }\n        // ensure it's a multiple of 256k\n        this.chunkSize = Math.ceil(unevenChunkSize / 256) * 256;\n\n        // Re-estimate the total number of chunks, by adding the completed\n        // chunks to the remaining chunks\n        const remainingChunks =\n          (this.file.size - this.nextChunkRangeStart) / this.chunkByteSize;\n        this.totalChunks = Math.ceil(this.chunkCount + remainingChunks);\n      }\n\n      return true;\n    };\n\n    // What to do if a chunk upload failed, potentially after retries\n    const failedChunkUploadCb = async (res: XhrResponseLike, _chunk?: Blob) => {\n      this.dispatch('progress', Math.min(this.successfulPercentage * 100, 100));\n      // Side effects\n      this.dispatch('error', {\n        message: `Server responded with ${res.statusCode}. Stopping upload.`,\n        chunk: this.chunkCount,\n        attempts: this.attemptCount,\n        response: res,\n      });\n\n      return false;\n    };\n\n    // What to do if a chunk upload failed but is retriable and hasn't exceeded retry\n    // count\n    const retriableChunkUploadCb = async (\n      res: XhrResponseLike | undefined,\n      _chunk?: Blob\n    ) => {\n      // Side effects\n      this.dispatch('attemptFailure', {\n        message: `An error occured uploading chunk ${this.chunkCount}. ${\n          this.attempts - this.attemptCount\n        } retries left.`,\n        chunkNumber: this.chunkCount,\n        attemptsLeft: this.attempts - this.attemptCount,\n        response: res,\n      });\n\n      return new Promise<boolean>((resolve) => {\n        setTimeout(async () => {\n          // Handle mid-flight _paused/offline cases here by storing the\n          // \"still retriable but yet to be uploaded chunk\" in state.\n          // See also: `sendChunks()`\n          if (this._paused || this.offline) {\n            this.pendingChunk = chunk;\n            resolve(false);\n            return;\n          }\n          const chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n          resolve(chunkUploadSuccess);\n        }, this.delayBeforeAttempt * 1000);\n      });\n    };\n\n    let res: XhrResponseLike | undefined;\n    try {\n      this.attemptCount = this.attemptCount + 1;\n      this.lastChunkStart = new Date();\n      res = await this.sendChunk(chunk);\n    } catch (err: unknown) {\n      // Account for failed attempts due to becoming offline while making a request.\n      if (typeof (err as any)?.statusCode === 'number') {\n        res = err as XhrResponseLike;\n      }\n    }\n    const options = {\n      retryCodes: this.retryCodes,\n      attemptCount: this.attemptCount,\n      attempts: this.attempts,\n      currentChunkEndByte: this.nextChunkRangeStart + chunk.size - 1, // end byte is inclusive\n    };\n    if (isIncompleteChunkUploadNeedingRetry(res, options)) {\n      return retriableChunkUploadCb(res, chunk);\n    }\n    if (isSuccessfulChunkUpload(res, options)) {\n      return successfulChunkUploadCb(res, chunk);\n    }\n    if (isFailedChunkUpload(res, options)) {\n      return failedChunkUploadCb(res, chunk);\n    }\n    // Retriable case\n    return retriableChunkUploadCb(res, chunk);\n  }\n\n  /**\n   * Manage the whole upload by calling getChunk & sendChunk\n   * handle errors & retries and dispatch events\n   */\n  private async sendChunks() {\n    // A \"pending chunk\" is a chunk that was unsuccessful but still retriable when\n    // uploading was _paused or the env is offline. Since this may be the last chunk,\n    // we account for it outside of the loop.\n    if (this.pendingChunk && !(this._paused || this.offline)) {\n      const chunk = this.pendingChunk;\n      this.pendingChunk = undefined;\n      const chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n      if (this.success && chunkUploadSuccess) {\n        this.dispatch('success');\n      }\n    }\n\n    while (!(this.success || this._paused || this.offline)) {\n      const { value: chunk, done } = await this.chunkedIterator.next();\n      // NOTE: When `done`, `chunk` is undefined, so default `chunkUploadSuccess`\n      // to be `true` on this condition, otherwise `false`.\n      let chunkUploadSuccess = !chunk && done;\n      if (chunk) {\n        chunkUploadSuccess = await this.sendChunkWithRetries(chunk);\n      }\n\n      if (this.chunkedIterable.error) {\n        chunkUploadSuccess = false;\n        this.dispatch('error', {\n          message: `Unable to read file of size ${this.file.size} bytes. Try loading from another browser.`,\n        });\n        return;\n      }\n      // NOTE: Need to disambiguate \"last chunk to upload\" (done) vs. \"successfully\"\n      // uploaded last chunk to upload\" (depends on status of sendChunkWithRetries),\n      // specifically for \"pending chunk\" cases for the last chunk.\n      this.success = !!done;\n      if (this.success && chunkUploadSuccess) {\n        this.dispatch('success');\n      }\n      if (!chunkUploadSuccess) {\n        return;\n      }\n    }\n  }\n}\n\nexport function createUpload(options: UpChunkOptions) {\n  return UpChunk.createUpload(options);\n}\n", "import type MuxUploaderElement from '../mux-uploader';\n\nexport const closestComposedNode = (childNode: Element, selector: string): HTMLElement | null => {\n  if (!childNode) return null;\n  const closest = childNode.closest<HTMLElement>(selector);\n  if (closest) return closest;\n  return closestComposedNode((childNode.getRootNode() as ShadowRoot).host, selector);\n};\n\nexport const getMuxUploaderEl = (controlEl: Element): MuxUploaderElement | null => {\n  const muxUploaderId = controlEl.getAttribute('mux-uploader');\n  if (muxUploaderId) {\n    return document.getElementById(muxUploaderId) as MuxUploaderElement;\n  }\n  return closestComposedNode(controlEl, 'mux-uploader') as MuxUploaderElement;\n};\n", "import { globalThis, document } from './polyfills';\nimport { getMuxUploaderEl } from './utils/element-utils';\nimport type MuxUploaderElement from './mux-uploader';\n\nconst template = document.createElement('template');\n\ntemplate.innerHTML = /*html*/ `\n<style>\n  :host {\n    position: relative;\n    box-sizing: border-box;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    border: 2px dashed #ccc;\n    padding: 2.5rem 2rem;\n    border-radius: .25rem;\n  }\n\n  slot[name='heading'] > * {\n    margin-bottom: 0.75rem;\n    font-size: 1.75rem;\n    text-align: center;\n  }\n\n  slot[name='separator'] > * {\n    margin-bottom: 0.75rem;\n  }\n\n  #overlay {\n    display: none;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n  }\n\n  :host([active][overlay]) > #overlay {\n    background: var(--overlay-background-color, rgba(226, 253, 255, 0.95));\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n  }\n\n  :host([file-ready])::part(heading),\n  :host([file-ready])::part(separator) {\n    display: none;\n  }\n</style>\n\n<slot name=\"heading\" part=\"heading\">\n  <span>Drop a video file here to upload</span>\n</slot>\n<slot name=\"separator\" part=\"separator\">\n  <span>or</span>\n</slot>\n<slot></slot>\n\n<div id=\"overlay\">\n  <h1 id=\"overlay-label\"></h1>\n</div>\n`;\n\nconst Attributes = {\n  MUX_UPLOADER: 'mux-uploader',\n  OVERLAY_TEXT: 'overlay-text',\n};\n\nclass MuxUploaderDropElement extends globalThis.HTMLElement {\n  #overlayTextEl: HTMLElement;\n  #uploaderEl: MuxUploaderElement | null | undefined;\n\n  #abortController: AbortController | undefined;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(template.content.cloneNode(true));\n\n    this.#overlayTextEl = shadowRoot.getElementById('overlay-label') as HTMLElement;\n  }\n\n  connectedCallback() {\n    this.#uploaderEl = getMuxUploaderEl(this);\n    this.#abortController = new AbortController();\n\n    if (this.#uploaderEl) {\n      const opts = { signal: this.#abortController.signal };\n\n      this.#uploaderEl.addEventListener('file-ready', () => this.toggleAttribute('file-ready', true), opts);\n      this.#uploaderEl.addEventListener('uploadstart', () => this.toggleAttribute('upload-in-progress', true), opts);\n      this.#uploaderEl.addEventListener(\n        'success',\n        () => {\n          this.toggleAttribute('upload-in-progress', false);\n          this.toggleAttribute('upload-complete', true);\n        },\n        opts\n      );\n      this.#uploaderEl.addEventListener(\n        'reset',\n        () => {\n          this.toggleAttribute('file-ready', false);\n          this.toggleAttribute('upload-in-progress', false);\n          this.toggleAttribute('upload-complete', false);\n        },\n        opts\n      );\n\n      this.setupDragEvents(opts);\n\n      this.toggleAttribute('upload-in-progress', this.#uploaderEl.hasAttribute('upload-in-progress'));\n      this.toggleAttribute('upload-complete', this.#uploaderEl.hasAttribute('upload-complete'));\n      this.toggleAttribute('file-ready', this.#uploaderEl.hasAttribute('file-ready'));\n    }\n  }\n\n  disconnectedCallback() {\n    this.#abortController?.abort();\n  }\n\n  attributeChangedCallback(attributeName: string, oldValue: string | null, newValue: string | null) {\n    if (attributeName === Attributes.OVERLAY_TEXT && oldValue !== newValue) {\n      this.#overlayTextEl.innerHTML = newValue ?? '';\n    } else if (attributeName === 'active') {\n      if (this.hasAttribute('overlay') && newValue != null) {\n        this._currentDragTarget = this;\n      }\n    }\n  }\n\n  static get observedAttributes() {\n    return [Attributes.OVERLAY_TEXT, Attributes.MUX_UPLOADER, 'active'];\n  }\n\n  protected _currentDragTarget?: Node;\n\n  setupDragEvents(opts: AddEventListenerOptions) {\n    this.addEventListener(\n      'dragenter',\n      (evt) => {\n        this._currentDragTarget = evt.target as Node;\n        evt.preventDefault();\n        evt.stopPropagation();\n        this.toggleAttribute('active', true);\n      },\n      opts\n    );\n\n    this.addEventListener(\n      'dragleave',\n      (evt) => {\n        if (this._currentDragTarget === evt.target) {\n          this._currentDragTarget = undefined;\n          this.toggleAttribute('active', false);\n        }\n      },\n      opts\n    );\n\n    this.addEventListener(\n      'dragover',\n      (evt) => {\n        evt.preventDefault();\n        evt.stopPropagation();\n      },\n      opts\n    );\n\n    this.addEventListener(\n      'drop',\n      (evt) => {\n        evt.preventDefault();\n        evt.stopPropagation();\n        const { dataTransfer } = evt;\n        //@ts-ignore\n        const { files } = dataTransfer;\n        const file = files[0];\n\n        const uploaderController = this.#uploaderEl ?? this;\n\n        uploaderController.dispatchEvent(\n          new CustomEvent('file-ready', {\n            composed: true,\n            bubbles: true,\n            detail: file,\n          })\n        );\n\n        this.removeAttribute('active');\n      },\n      opts\n    );\n  }\n}\n\nif (!globalThis.customElements.get('mux-uploader-drop')) {\n  globalThis.customElements.define('mux-uploader-drop', MuxUploaderDropElement);\n  //@ts-ignore\n  globalThis.MuxUploaderDropElement = MuxUploaderDropElement;\n}\n\nexport default MuxUploaderDropElement;\n", "export function formatProgress(percent: number): string {\n  return `${Math.floor(percent)}%`;\n}\n", "import { globalThis, document } from './polyfills';\nimport { ProgressTypes } from './constants';\nimport { getMuxUploaderEl } from './utils/element-utils';\nimport { formatProgress } from './utils/progress';\n\nconst template = document.createElement('template');\nconst ariaDescription = 'Media upload progress bar';\n\ntemplate.innerHTML = /*html*/ `\n<style>\n  :host {\n    width: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-direction: column;\n  }\n\n  .bar-type {\n    background: var(--progress-bar-background-color, #e6e6e6);\n    border-radius: var(--progress-bar-border-radius, 100px);\n    height: var(--progress-bar-height, 4px);\n    width: 100%;\n  }\n\n  .radial-type,\n  .bar-type,\n  #percentage-type,\n  :host([type=\"bar\"][upload-error]) #percentage-type {\n    display: none;\n  }\n\n  :host([type=\"radial\"][upload-in-progress]) .radial-type,\n  :host([type=\"bar\"][upload-in-progress]) .bar-type {\n    display: block;\n  }\n\n  :host([type=\"percentage\"][upload-in-progress]) #percentage-type {\n    display: var(--progress-percentage-display, block);\n  }\n\n  :host([type=\"bar\"][upload-error]) .progress-bar {\n    background: #e22c3e;\n  }\n\n  .progress-bar {\n    box-shadow: var(--progress-bar-box-shadow, 0 10px 40px -10px #fff);\n    border-radius: var(--progress-bar-border-radius, 100px);\n    background: var(--progress-bar-fill-color, #000000);\n    height: var(--progress-bar-height, 4px);\n    width: 0%;\n    transition: width 0.25s;\n  }\n\n  circle {\n    stroke: var(--progress-radial-fill-color, black);\n    stroke-width: 6;  /* Thickness of the circle */\n    fill: transparent; /* Make inside of the circle see-through */\n\n    /* Animation */\n    transition: 0.35s;\n    transform: rotate(-90deg);\n    transform-origin: 50% 50%;\n    -webkit-transform-origin: 50% 50%;\n    -moz-transform-origin: 50% 50%;\n  }\n\n  #percentage-type {\n    font-size: inherit;\n    margin: 0 0 1em;\n  }\n</style>\n\n<slot></slot>\n\n<p id=\"percentage-type\"></p>\n<div class=\"bar-type\">\n  <div role=\"progressbar\" aria-valuemin=\"0\" aria-valuemax=\"100\" class=\"progress-bar\" id=\"progress-bar\" tabindex=\"0\"></div>\n</div>\n<div class=\"radial-type\">\n  <svg\n    width=\"120\"\n    height=\"120\">\n    <!-- To prevent overflow of the SVG wrapper, radius must be  (svgWidth / 2) - (circleStrokeWidth * 2)\n      or use overflow: visible on the svg.-->\n    <circle\n      r=\"52\"\n      cx=\"60\"\n      cy=\"60\"\n    />\n  <svg>\n</div>\n`;\n\nclass MuxUploaderProgressElement extends globalThis.HTMLElement {\n  #uploaderEl: HTMLElement | null | undefined;\n  #abortController: AbortController | undefined;\n\n  svgCircle: SVGCircleElement | null | undefined;\n  progressBar: HTMLElement | null | undefined;\n  uploadPercentage: HTMLElement | null | undefined;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(template.content.cloneNode(true));\n\n    this.svgCircle = this.shadowRoot?.querySelector('circle');\n    this.progressBar = this.shadowRoot?.getElementById('progress-bar');\n    this.uploadPercentage = this.shadowRoot?.getElementById('percentage-type');\n    this.progressBar?.setAttribute('aria-description', ariaDescription);\n  }\n\n  connectedCallback() {\n    this.setDefaultType();\n\n    this.#uploaderEl = getMuxUploaderEl(this);\n    this.#abortController = new AbortController();\n\n    if (this.#uploaderEl) {\n      const opts = { signal: this.#abortController.signal };\n\n      this.#uploaderEl.addEventListener('uploadstart', this.onUploadStart, opts);\n      this.#uploaderEl.addEventListener('reset', this.onReset);\n      this.#uploaderEl.addEventListener('progress', this.onProgress);\n      this.#uploaderEl.addEventListener('success', this.onSuccess);\n      this.toggleAttribute('upload-in-progress', this.#uploaderEl.hasAttribute('upload-in-progress'));\n      this.toggleAttribute('upload-complete', this.#uploaderEl.hasAttribute('upload-complete'));\n    }\n  }\n\n  disconnectedCallback() {\n    this.#abortController?.abort();\n  }\n\n  onUploadStart = () => {\n    this.progressBar?.focus();\n    this.toggleAttribute('upload-in-progress', true);\n  };\n\n  onProgress = (e: Event) => {\n    // @ts-ignore\n    const percent = e.detail;\n    this.progressBar?.setAttribute('aria-valuenow', `${Math.floor(percent)}`);\n\n    switch (this.getAttribute('type')) {\n      case ProgressTypes.BAR: {\n        if (this.progressBar) {\n          this.progressBar.style.width = `${percent}%`;\n        }\n        break;\n      }\n      case ProgressTypes.RADIAL: {\n        if (this.svgCircle) {\n          // The closer the upload percentage gets to 100%, the closer offset gets to 0.\n          // The closer offset gets to 0, the more we can see the circumference of our circle. (TD).\n          const offset = this.getCircumference() - (percent / 100) * this.getCircumference();\n\n          this.svgCircle.style.strokeDashoffset = offset.toString();\n        }\n        break;\n      }\n      case ProgressTypes.PERCENTAGE: {\n        if (this.uploadPercentage) this.uploadPercentage.innerHTML = formatProgress(percent);\n        break;\n      }\n    }\n  };\n\n  onSuccess = () => {\n    this.toggleAttribute('upload-in-progress', false);\n    this.toggleAttribute('upload-complete', true);\n  };\n\n  onReset = () => {\n    this.toggleAttribute('upload-in-progress', false);\n    if (this.uploadPercentage) {\n      this.uploadPercentage.innerHTML = '';\n    }\n\n    if (this.svgCircle) {\n      this.svgCircle.style.strokeDashoffset = `${this.getCircumference()}`;\n    }\n  };\n\n  getRadius() {\n    return Number(this.svgCircle?.getAttribute('r'));\n  }\n\n  getCircumference() {\n    return this.getRadius() * 2 * Math.PI;\n  }\n\n  setDefaultType() {\n    const currentType = this.getAttribute('type');\n\n    if (!currentType) {\n      this.setAttribute('type', ProgressTypes.BAR);\n    }\n\n    if (currentType === ProgressTypes.RADIAL && this.svgCircle) {\n      // strokeDasharray is the size of dashes used to draw the circle with the size of gaps in between.\n      // If the dash number is the same as the gap number, no gap is visible: a full circle.\n      // strokeDashoffset defines where along our circle the dashes (in our case, a dash as long as the\n      // circumference of our circle) begins. The larger the offset, the farther into the circle you're\n      // starting the \"dash\". In the beginning, offset is the same as the circumference. Meaning, the visible\n      // dash starts at the end so we don't see the full circle. Instead we see a gap the size of the circle.\n      // When the percentage is 100%, offset is 0 meaning the dash starts at the beginning so we can see the circle. (TD).\n      this.svgCircle.style.strokeDasharray = `${this.getCircumference()} ${this.getCircumference()}`;\n      this.svgCircle.style.strokeDashoffset = `${this.getCircumference()}`;\n    }\n  }\n}\n\nif (!globalThis.customElements.get('mux-uploader-progress')) {\n  globalThis.customElements.define('mux-uploader-progress', MuxUploaderProgressElement);\n}\n\nexport default MuxUploaderProgressElement;\n", "import { globalThis, document } from './polyfills';\nimport { getMuxUploaderEl } from './utils/element-utils';\nimport { type MuxUploaderElementEventMap } from './mux-uploader';\nimport type MuxUploaderElement from './mux-uploader';\n\nconst template = document.createElement('template');\n\ntemplate.innerHTML = `\n<style>\n\n:host([upload-error]) {\n  color: #e22c3e;\n}\n</style>\n\n<span id=\"status-message\" role=\"status\" aria-live=\"polite\"></span>\n`;\n\nclass MuxUploaderStatusElement extends globalThis.HTMLElement {\n  statusMessage: HTMLElement | null | undefined;\n  #uploaderEl: MuxUploaderElement | null | undefined;\n  #abortController: AbortController | undefined;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(template.content.cloneNode(true));\n\n    this.statusMessage = this.shadowRoot?.getElementById('status-message');\n  }\n\n  connectedCallback() {\n    this.#uploaderEl = getMuxUploaderEl(this);\n    this.#abortController = new AbortController();\n\n    if (this.#uploaderEl) {\n      const opts = { signal: this.#abortController.signal };\n      this.#uploaderEl.addEventListener('reset', this.clearStatusMessage, opts);\n      this.#uploaderEl.addEventListener('uploaderror', this.onUploadError, opts);\n      this.#uploaderEl.addEventListener('success', this.onSuccess, opts);\n      this.#uploaderEl.addEventListener('uploadstart', this.clearStatusMessage, opts);\n      this.#uploaderEl.addEventListener('offline', this.onOffline, opts);\n      this.#uploaderEl.addEventListener('online', this.clearStatusMessage, opts);\n\n      this.toggleAttribute('upload-in-progress', this.#uploaderEl.hasAttribute('upload-in-progress'));\n      this.toggleAttribute('upload-complete', this.#uploaderEl.hasAttribute('upload-complete'));\n      this.toggleAttribute('upload-error', this.#uploaderEl.hasAttribute('upload-error'));\n    }\n  }\n\n  disconnectedCallback() {\n    this.#abortController?.abort();\n  }\n\n  clearStatusMessage = () => {\n    this.toggleAttribute('upload-error', false);\n    if (this.statusMessage) {\n      this.statusMessage.innerHTML = '';\n    }\n  };\n\n  onUploadError = (e: MuxUploaderElementEventMap['uploaderror']) => {\n    this.toggleAttribute('upload-error', true);\n    if (this.statusMessage) {\n      this.statusMessage.innerHTML = e.detail.message;\n    }\n  };\n\n  onSuccess = () => {\n    this.toggleAttribute('upload-error', false);\n    const successMessage = 'Upload complete!';\n\n    if (this.statusMessage) {\n      this.statusMessage.innerHTML = successMessage;\n    }\n\n    console.info(successMessage);\n  };\n\n  onOffline = () => {\n    this.toggleAttribute('upload-error', false);\n    const offlineMessage = 'Currently offline. Upload will resume automatically when online.';\n\n    if (this.statusMessage) {\n      this.statusMessage.innerHTML = offlineMessage;\n    }\n  };\n}\n\nif (!globalThis.customElements.get('mux-uploader-status')) {\n  globalThis.customElements.define('mux-uploader-status', MuxUploaderStatusElement);\n}\n\nexport default MuxUploaderStatusElement;\n", "import { globalThis, document } from './polyfills';\nimport { getMuxUploaderEl } from './utils/element-utils';\nimport type MuxUploaderElement from './mux-uploader';\n\nconst template = document.createElement('template');\n\ntemplate.innerHTML = `\n<style>\n  #retry-button {\n    color: #e22c3e;\n    text-decoration-line: underline;\n    cursor: pointer;\n    position: relative;\n    display: none;\n  }\n\n  :host([upload-error]) #retry-button {\n    display: inline-block;\n  }\n</style>\n\n<span id=\"retry-button\" role=\"button\" tabindex=\"0\">Try again</span>\n`;\n\nclass MuxUploaderRetryElement extends globalThis.HTMLElement {\n  retryButton: HTMLElement | null | undefined;\n  #uploaderEl: MuxUploaderElement | null | undefined;\n  #abortController: AbortController | undefined;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(template.content.cloneNode(true));\n\n    this.retryButton = this.shadowRoot?.getElementById('retry-button');\n  }\n\n  connectedCallback() {\n    this.#uploaderEl = getMuxUploaderEl(this);\n    this.#abortController = new AbortController();\n\n    if (this.#uploaderEl) {\n      const opts = { signal: this.#abortController.signal };\n      this.#uploaderEl.addEventListener('uploaderror', () => this.toggleAttribute('upload-error', true));\n      this.#uploaderEl.addEventListener('reset', () => this.toggleAttribute('upload-error', false));\n      this.retryButton?.addEventListener('click', this.triggerReset, opts);\n      this.retryButton?.addEventListener('keyup', this.handleKeyup, opts);\n\n      this.toggleAttribute('upload-error', this.#uploaderEl.hasAttribute('upload-error'));\n    }\n  }\n\n  disconnectedCallback() {\n    this.#abortController?.abort();\n  }\n\n  handleKeyup = (e: KeyboardEvent) => {\n    const ButtonPressedKeys = ['Enter', ' '];\n    const { key } = e;\n    if (!ButtonPressedKeys.includes(key)) {\n      return;\n    }\n\n    this.triggerReset();\n  };\n\n  triggerReset = () => {\n    this.#uploaderEl?.dispatchEvent(new CustomEvent('reset'));\n  };\n}\n\nif (!globalThis.customElements.get('mux-uploader-retry')) {\n  globalThis.customElements.define('mux-uploader-retry', MuxUploaderRetryElement);\n}\n\nexport default MuxUploaderRetryElement;\n", "import { globalThis, document } from './polyfills';\nimport { getMuxUploaderEl } from './utils/element-utils';\nimport type MuxUploaderElement from './mux-uploader';\n\nconst template = document.createElement('template');\n\ntemplate.innerHTML = /*html*/ `\n<style>\n#pause-button {\n  cursor: pointer;\n  line-height: 16px;\n  background: #fff;\n  border: 1px solid #000;\n  color: #000000;\n  padding: 16px 24px;\n  border-radius: 4px;\n  -webkit-transition: all 0.2s ease;\n  transition: all 0.2s ease;\n  font-family: inherit;\n  font-size: inherit;\n  position: relative;\n  display: none;\n}\n\n#pause-button:hover:not(:disabled) {\n  color: #fff;\n  background: #404040;\n}\n\n#pause-button:active {\n  color: #fff;\n  background: #000;\n}\n\n#pause-button:disabled {\n  cursor: not-allowed;\n}\n\n:host([upload-in-progress]:not([upload-error], [upload-complete])) #pause-button {\n  display: initial;\n}\n</style>\n\n<button id=\"pause-button\">Pause</span>\n`;\n\nclass MuxUploaderPauseElement extends globalThis.HTMLElement {\n  #uploaderEl: MuxUploaderElement | null | undefined;\n  #abortController: AbortController | undefined;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n\n  connectedCallback() {\n    this.#uploaderEl = getMuxUploaderEl(this);\n    this.#abortController = new AbortController();\n\n    if (this.#uploaderEl) {\n      const opts = { signal: this.#abortController.signal };\n      this.#uploaderEl.addEventListener('uploadstart', () => this.toggleAttribute('upload-in-progress', true), opts);\n      this.#uploaderEl.addEventListener('uploaderror', () => {\n        this.toggleAttribute('upload-error', true);\n        this.toggleAttribute('upload-complete', false);\n        this.toggleAttribute('upload-in-progress', false);\n      });\n      this.#uploaderEl.addEventListener('success', () => {\n        this.toggleAttribute('upload-complete', true);\n        this.toggleAttribute('upload-error', false);\n        this.toggleAttribute('upload-in-progress', false);\n      });\n      this.#uploaderEl.addEventListener('reset', () => {\n        this.toggleAttribute('upload-error', false);\n        this.toggleAttribute('upload-in-progress', false);\n        this.toggleAttribute('upload-complete', false);\n      });\n      /** @TODO Implement a more robust \"pausedState\" in mux-uploader (plausibly in upchunk) to account for \"pausing\" (CJP) */\n      this.#uploaderEl.addEventListener('pausedchange', () => {\n        this.pauseButton.disabled = false;\n        if (!this.#uploaderEl) return;\n        const nextPausedState = this.#uploaderEl.paused ?? false;\n        // If entered paused, currently does not take effect until current chunk completes upload,\n        // so show as \"pausing\"\n        this.pauseButton.innerHTML = nextPausedState ? 'Pausing...' : 'Pause';\n        if (nextPausedState) {\n          this.pauseButton.disabled = true;\n          this.#uploaderEl.addEventListener(\n            'chunksuccess',\n            () => {\n              // Recheck paused state just in case state changed while waiting for 'chunksuccess'\n              this.pauseButton.innerHTML = this.#uploaderEl?.paused ? 'Resume' : 'Pause';\n              this.pauseButton.disabled = false;\n            },\n            { once: true }\n          );\n        }\n      });\n\n      this.pauseButton.addEventListener('click', this.triggerPause, opts);\n\n      this.toggleAttribute('upload-in-progress', this.#uploaderEl.hasAttribute('upload-in-progress'));\n      this.toggleAttribute('upload-complete', this.#uploaderEl.hasAttribute('upload-complete'));\n      this.toggleAttribute('upload-error', this.#uploaderEl.hasAttribute('upload-error'));\n    }\n  }\n\n  disconnectedCallback() {\n    this.#abortController?.abort();\n  }\n\n  get pauseButton() {\n    return this.shadowRoot?.getElementById('pause-button') as HTMLButtonElement;\n  }\n\n  triggerPause = () => {\n    if (!this.#uploaderEl) {\n      console.warn('pausing before a mux-uploader element is associated is unsupported!');\n      return;\n    }\n    if (this.pauseButton.disabled) {\n      return;\n    }\n    this.#uploaderEl.paused = !this.#uploaderEl.paused;\n  };\n}\n\nif (!globalThis.customElements.get('mux-uploader-pause')) {\n  globalThis.customElements.define('mux-uploader-pause', MuxUploaderPauseElement);\n}\n\nexport default MuxUploaderPauseElement;\n", "import { globalThis, document } from './polyfills';\nimport { getMuxUploaderEl } from './utils/element-utils';\nimport type MuxUploaderElement from './mux-uploader';\n\nexport const fileSelectFragment = /*html*/ `\n  <style>\n  #file-select {\n    cursor: pointer;\n    line-height: 16px;\n    background: #fff;\n    border: 1px solid #000;\n    color: #000000;\n    padding: 16px 24px;\n    border-radius: 4px;\n    -webkit-transition: all 0.2s ease;\n    transition: all 0.2s ease;\n    font-family: inherit;\n    font-size: inherit;\n    position: relative;\n  }\n\n  #file-select:hover {\n    color: #fff;\n    background: #404040;\n  }\n\n  #file-select:active {\n    color: #fff;\n    background: #000;\n  }\n\n  </style>\n\n  <button id=\"file-select\" type=\"button\" part=\"file-select-button\">Upload a video</button>\n`;\n\nconst template = document.createElement('template');\n\ntemplate.innerHTML = /*html*/ `\n  <style>\n    :host { display: inline-block; }\n\n    :host([file-ready]) > slot  {\n      display: none;\n    }\n  </style>\n\n  <slot>\n    ${fileSelectFragment}\n  </slot>\n`;\n\nclass MuxUploaderFileSelectElement extends globalThis.HTMLElement {\n  #filePickerEl: HTMLElement | null | undefined;\n  #uploaderEl: MuxUploaderElement | null | undefined;\n\n  #abortController: AbortController | undefined;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(template.content.cloneNode(true));\n\n    // NOTE: Binding this so that we have a reference to remove the event listener\n    // but can still reference `this` in the method. (CJP)\n    this.handleFilePickerElClick = this.handleFilePickerElClick.bind(this);\n\n    // Since we have a \"default slotted\" element, we still need to initialize the slottable elements\n    // (Note the difference in selectors and related code in 'slotchange' handler, below)\n    this.filePickerEl = this.shadowRoot?.querySelector('button');\n\n    this.shadowRoot?.querySelector('slot')?.addEventListener('slotchange', (e) => {\n      const slot = e.currentTarget as HTMLSlotElement;\n      this.filePickerEl = slot\n        .assignedElements({ flatten: true })\n        .filter((el) => !['STYLE'].includes(el.nodeName))[0] as HTMLButtonElement;\n    });\n  }\n\n  connectedCallback() {\n    this.#uploaderEl = getMuxUploaderEl(this);\n    this.#abortController = new AbortController();\n\n    if (this.#uploaderEl) {\n      const opts = { signal: this.#abortController.signal };\n\n      this.#uploaderEl.addEventListener(\n        'file-ready',\n        () => {\n          this.toggleAttribute('file-ready', true);\n        },\n        opts\n      );\n\n      this.#uploaderEl.addEventListener('uploadstart', () => this.toggleAttribute('upload-in-progress', true), opts);\n\n      this.#uploaderEl.addEventListener(\n        'success',\n        () => {\n          this.toggleAttribute('upload-in-progress', false);\n          this.toggleAttribute('upload-complete', true);\n        },\n        opts\n      );\n\n      this.#uploaderEl.addEventListener(\n        'reset',\n        () => {\n          this.toggleAttribute('file-ready', false);\n        },\n        opts\n      );\n\n      this.toggleAttribute('upload-in-progress', this.#uploaderEl.hasAttribute('upload-in-progress'));\n      this.toggleAttribute('upload-complete', this.#uploaderEl.hasAttribute('upload-complete'));\n      this.toggleAttribute('file-ready', this.#uploaderEl.hasAttribute('file-ready'));\n    }\n  }\n\n  disconnectedCallback() {\n    this.#abortController?.abort();\n  }\n\n  protected get filePickerEl() {\n    return this.#filePickerEl;\n  }\n\n  protected set filePickerEl(value: HTMLElement | null | undefined) {\n    if (value === this.#filePickerEl) return;\n    if (this.#filePickerEl) {\n      this.#filePickerEl.removeEventListener('click', this.handleFilePickerElClick);\n    }\n\n    this.#filePickerEl = value;\n    if (this.#filePickerEl) {\n      this.#filePickerEl.addEventListener('click', this.handleFilePickerElClick);\n    }\n  }\n\n  handleFilePickerElClick() {\n    // TO-DO: Allow user to reattempt uploading the same file after an error.\n    // Note: Apparently Chrome and Firefox do not allow changing an indexed property on FileList...(TD).\n    // Source: https://stackoverflow.com/a/46689013\n    const attr = this.getAttribute('mux-uploader');\n    const controller = attr ? document.getElementById(attr) : (this.getRootNode() as ShadowRoot).host;\n\n    controller?.shadowRoot?.querySelector<HTMLInputElement>('#hidden-file-input')?.click();\n  }\n}\n\nif (!globalThis.customElements.get('mux-uploader-file-select')) {\n  globalThis.customElements.define('mux-uploader-file-select', MuxUploaderFileSelectElement);\n}\n\nexport default MuxUploaderFileSelectElement;\n", "import { document } from '../polyfills';\n\nimport '../mux-uploader-drop';\nimport '../mux-uploader-progress';\nimport '../mux-uploader-status';\nimport '../mux-uploader-retry';\nimport '../mux-uploader-pause';\nimport '../mux-uploader-file-select';\nimport { fileSelectFragment } from '../mux-uploader-file-select';\nimport MuxUploaderElement from '../mux-uploader';\n\nfunction conditionalRender(flag: boolean | undefined, component: string): string {\n  return flag ? '' : component;\n}\n\nconst attributeRender = (name: string, value: any): string => {\n  if (value == null || value === false) return '';\n  const valueStr = value === true ? '' : `${value}`;\n  return `${name}=\"${valueStr}\"`;\n};\n\nexport default function blockLayout(contextElement: MuxUploaderElement): DocumentFragment {\n  const { noDrop, noProgress, noStatus, noRetry, pausable, type } = contextElement;\n  const wrapper = noDrop ? 'div' : 'mux-uploader-drop overlay part=\"drop\"';\n  const progressElements = conditionalRender(\n    noProgress,\n    `\n      <mux-uploader-progress part=\"progress progress-percentage\" type=\"percentage\"></mux-uploader-progress>\n      <mux-uploader-progress part=\"progress progress-bar\" ${attributeRender('type', type)}></mux-uploader-progress>\n    `\n  );\n  const statusElement = conditionalRender(noStatus, '<mux-uploader-status part=\"status\"></mux-uploader-status>');\n  const retryElement = conditionalRender(noRetry, '<mux-uploader-retry part=\"retry\"></mux-uploader-retry>');\n  const pauseElement = conditionalRender(!pausable, '<mux-uploader-pause part=\"pause\"></mux-uploader-pause>');\n\n  return document.createRange().createContextualFragment(`\n    <${wrapper}>\n      ${statusElement}\n      ${retryElement}\n      ${pauseElement}\n\n      <mux-uploader-file-select part=\"file-select\">\n        <slot name=\"file-select\">\n          ${fileSelectFragment}\n        </slot>\n      </mux-uploader-file-select>\n\n      ${progressElements}\n    </${wrapper}>\n  `);\n}\n", "import { globalThis, document } from './polyfills';\n\nimport { UpChunk } from '@mux/upchunk';\n\nimport blockLayout from './layouts/block';\nimport { ProgressTypes } from './constants';\n\nconst rootTemplate = document.createElement('template');\n\nrootTemplate.innerHTML = /*html*/ `\n<style>\n  :host {\n    display: flex;\n    flex-direction: column;\n  }\n\n  mux-uploader-drop {\n    flex-grow: 1;\n  }\n\n  input[type=\"file\"] {\n    display: none;\n  }\n</style>\n\n<input id=\"hidden-file-input\" type=\"file\" accept=\"video/*, audio/*\" />\n<mux-uploader-sr-text></mux-uploader-sr-text>\n`;\n\ntype Endpoint = UpChunk['endpoint'] | undefined | null;\ntype DynamicChunkSize = UpChunk['dynamicChunkSize'] | undefined;\n\ntype ErrorDetail = {\n  message: string;\n  chunkNumber?: number;\n  attempts?: number;\n};\n\n// NOTE: Progress event is already determined on HTMLElement but have inconsistent types. Should consider renaming events (CJP)\nexport interface MuxUploaderElementEventMap extends Omit<HTMLElementEventMap, 'progress'> {\n  uploadstart: CustomEvent<{ file: File; chunkSize: number }>;\n  chunkattempt: CustomEvent<{\n    chunkNumber: number;\n    chunkSize: number;\n  }>;\n  chunksuccess: CustomEvent<{\n    chunk: number;\n    chunkSize: number;\n    attempts: number;\n    timeInterval: number;\n    // Note: This should be more explicitly typed in Upchunk. (TD).\n    response: any;\n  }>;\n  uploaderror: CustomEvent<ErrorDetail>;\n  progress: CustomEvent<number>;\n  success: CustomEvent<undefined | null>;\n  'file-ready': CustomEvent<File>;\n}\n\ninterface MuxUploaderElement extends HTMLElement {\n  addEventListener<K extends keyof MuxUploaderElementEventMap>(\n    type: K,\n    listener: (this: HTMLMediaElement, ev: MuxUploaderElementEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener<K extends keyof MuxUploaderElementEventMap>(\n    type: K,\n    listener: (this: HTMLMediaElement, ev: MuxUploaderElementEventMap[K]) => any,\n    options?: boolean | EventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions\n  ): void;\n}\n\nclass MuxUploaderElement extends globalThis.HTMLElement implements MuxUploaderElement {\n  static get observedAttributes() {\n    return [\n      'pausable',\n      'type',\n      'no-drop',\n      'no-progress',\n      'no-status',\n      'no-retry',\n      'max-file-size',\n      'use-large-file-workaround',\n    ];\n  }\n\n  protected _endpoint: Endpoint;\n  protected _upload?: UpChunk;\n\n  constructor() {\n    super();\n\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    // Always attach the root template\n    shadow.appendChild(rootTemplate.content.cloneNode(true));\n\n    // Attach a layout\n    this.updateLayout();\n\n    this.hiddenFileInput?.addEventListener('change', () => {\n      const file = this.hiddenFileInput?.files?.[0];\n      this.toggleAttribute('file-ready', !!file);\n\n      if (file) {\n        this.dispatchEvent(\n          new CustomEvent('file-ready', {\n            composed: true,\n            bubbles: true,\n            detail: file,\n          })\n        );\n      }\n    });\n  }\n\n  connectedCallback() {\n    this.addEventListener('file-ready', this.handleUpload);\n    this.addEventListener('reset', this.resetState);\n  }\n\n  disconnectedCallback() {\n    this.removeEventListener('file-ready', this.handleUpload, false);\n    this.removeEventListener('reset', this.resetState);\n  }\n\n  attributeChangedCallback() {\n    this.updateLayout();\n  }\n\n  protected get hiddenFileInput() {\n    return this.shadowRoot?.querySelector('#hidden-file-input') as HTMLInputElement;\n  }\n\n  get endpoint(): Endpoint {\n    return this.getAttribute('endpoint') ?? this._endpoint;\n  }\n\n  set endpoint(value: Endpoint) {\n    if (value === this.endpoint) return;\n    if (typeof value === 'string') {\n      this.setAttribute('endpoint', value);\n    } else if (value == undefined) {\n      this.removeAttribute('endpoint');\n    }\n    this._endpoint = value;\n  }\n\n  get type() {\n    return (this.getAttribute('type') ?? undefined) as ProgressTypes[keyof ProgressTypes] | undefined;\n  }\n\n  set type(val: ProgressTypes[keyof ProgressTypes] | undefined) {\n    if (val == this.type) return;\n    if (!val) {\n      this.removeAttribute('type');\n    } else {\n      this.setAttribute('type', val);\n    }\n  }\n\n  get noDrop(): boolean {\n    return this.hasAttribute('no-drop');\n  }\n\n  set noDrop(value: boolean) {\n    this.toggleAttribute('no-drop', Boolean(value));\n  }\n\n  get noProgress(): boolean {\n    return this.hasAttribute('no-progress');\n  }\n\n  set noProgress(value: boolean) {\n    this.toggleAttribute('no-progress', Boolean(value));\n  }\n\n  get noStatus(): boolean {\n    return this.hasAttribute('no-status');\n  }\n\n  set noStatus(value: boolean) {\n    this.toggleAttribute('no-status', Boolean(value));\n  }\n\n  get noRetry(): boolean {\n    return this.hasAttribute('no-retry');\n  }\n\n  set noRetry(value: boolean) {\n    this.toggleAttribute('no-retry', Boolean(value));\n  }\n\n  get pausable() {\n    return this.hasAttribute('pausable');\n  }\n\n  set pausable(value) {\n    this.toggleAttribute('pausable', Boolean(value));\n  }\n\n  get dynamicChunkSize(): DynamicChunkSize {\n    return this.hasAttribute('dynamic-chunk-size');\n  }\n\n  set dynamicChunkSize(value: DynamicChunkSize) {\n    if (value === this.hasAttribute('dynamic-chunk-size')) return;\n    if (value) {\n      this.setAttribute('dynamic-chunk-size', '');\n    } else {\n      this.removeAttribute('dynamic-chunk-size');\n    }\n  }\n\n  get useLargeFileWorkaround() {\n    return this.hasAttribute('use-large-file-workaround');\n  }\n\n  set useLargeFileWorkaround(value: boolean | undefined) {\n    if (value == this.useLargeFileWorkaround) return;\n    this.toggleAttribute('use-large-file-workaround', !!value);\n  }\n\n  get maxFileSize(): number | undefined {\n    const maxFileSize = this.getAttribute('max-file-size');\n    return maxFileSize !== null ? parseInt(maxFileSize) : undefined;\n  }\n\n  set maxFileSize(value: number | undefined) {\n    if (value) {\n      this.setAttribute('max-file-size', value.toString());\n    } else {\n      this.removeAttribute('max-file-size');\n    }\n  }\n\n  get chunkSize(): number | undefined {\n    const chunkSize = this.getAttribute('chunk-size');\n    return chunkSize !== null ? parseInt(chunkSize) : undefined;\n  }\n\n  set chunkSize(value: number | undefined) {\n    if (value) {\n      this.setAttribute('chunk-size', value.toString());\n    } else {\n      this.removeAttribute('chunk-size');\n    }\n  }\n\n  get upload() {\n    return this._upload;\n  }\n\n  get paused() {\n    return this.upload?.paused ?? false;\n  }\n\n  set paused(value) {\n    if (!this.upload) {\n      console.warn('Pausing before an upload has begun is unsupported');\n      return;\n    }\n    const boolVal = !!value;\n    if (boolVal === this.paused) return;\n    if (boolVal) {\n      this.upload.pause();\n    } else {\n      this.upload.resume();\n    }\n    this.toggleAttribute('paused', boolVal);\n    this.dispatchEvent(new CustomEvent('pausedchange', { detail: boolVal }));\n  }\n\n  updateLayout() {\n    const oldLayout = this.shadowRoot?.querySelector('mux-uploader-drop, div');\n    if (oldLayout) {\n      oldLayout.remove();\n    }\n    const newLayout = blockLayout(this);\n    this.shadowRoot?.appendChild(newLayout);\n  }\n\n  setError(message: string) {\n    this.setAttribute('upload-error', '');\n    this.dispatchEvent(new CustomEvent('uploaderror', { detail: { message } }));\n  }\n\n  resetState() {\n    this.removeAttribute('upload-error');\n    this.removeAttribute('upload-in-progress');\n    this.removeAttribute('upload-complete');\n    // Reset file to ensure change/input events will fire, even if selecting the same file (CJP).\n    this.hiddenFileInput.value = '';\n  }\n\n  handleUpload(evt: CustomEvent) {\n    const endpoint = this.endpoint;\n    const dynamicChunkSize = this.dynamicChunkSize;\n\n    if (!endpoint) {\n      this.setError(`No url or endpoint specified -- cannot handleUpload`);\n      // Bail early if no endpoint.\n      return;\n    } else {\n      this.removeAttribute('upload-error');\n    }\n\n    try {\n      const upload = UpChunk.createUpload({\n        endpoint,\n        dynamicChunkSize,\n        file: evt.detail,\n        maxFileSize: this.maxFileSize,\n        chunkSize: this.chunkSize,\n        useLargeFileWorkaround: this.useLargeFileWorkaround,\n      });\n\n      this._upload = upload;\n\n      this.dispatchEvent(\n        new CustomEvent('uploadstart', { detail: { file: upload.file, chunkSize: upload.chunkSize } })\n      );\n      this.setAttribute('upload-in-progress', '');\n\n      if (upload.offline) {\n        this.dispatchEvent(new CustomEvent('offline'));\n      }\n\n      upload.on('attempt', (event: any) => {\n        this.dispatchEvent(new CustomEvent('chunkattempt', event));\n      });\n\n      upload.on('chunkSuccess', (event: any) => {\n        this.dispatchEvent(new CustomEvent('chunksuccess', event));\n      });\n\n      upload.on('error', (event: any) => {\n        this.setAttribute('upload-error', '');\n        console.error('error handler', event.detail.message);\n        this.dispatchEvent(new CustomEvent('uploaderror', event));\n      });\n\n      upload.on('progress', (event: any) => {\n        this.dispatchEvent(new CustomEvent('progress', event));\n      });\n\n      upload.on('success', (event: any) => {\n        this.removeAttribute('upload-in-progress');\n        this.setAttribute('upload-complete', '');\n\n        this.dispatchEvent(new CustomEvent('success', event));\n      });\n\n      upload.on('offline', (event: any) => {\n        this.dispatchEvent(new CustomEvent('offline', event));\n      });\n      upload.on('online', (event: any) => {\n        this.dispatchEvent(new CustomEvent('online', event));\n      });\n    } catch (err) {\n      if (err instanceof Error) {\n        this.setError(err.message);\n      }\n    }\n  }\n}\n\ntype MuxUploaderElementType = typeof MuxUploaderElement;\ndeclare global {\n  // eslint-disable-next-line\n  var MuxUploaderElement: MuxUploaderElementType;\n}\n\nif (!globalThis.customElements.get('mux-uploader')) {\n  globalThis.customElements.define('mux-uploader', MuxUploaderElement);\n  globalThis.MuxUploaderElement = MuxUploaderElement;\n}\n\nexport default MuxUploaderElement;\n", "import { globalThis, document } from './polyfills';\nimport { getMuxUploaderEl } from './utils/element-utils';\n\nconst template = document.createElement('template');\n\ntemplate.innerHTML = `\n<style>\n\n.sr-only {\n  position:absolute;\n  left:-10000px;\n  top:auto;\n  width:1px;\n  height:1px;\n  overflow:hidden;\n}\n</style>\n\n<div class=\"sr-only\" id=\"sr-only\" aria-live=\"polite\"></div>\n`;\n\nclass MuxUploaderSrTextElement extends globalThis.HTMLElement {\n  srOnlyText: HTMLElement | null | undefined;\n  #uploaderEl: HTMLElement | null | undefined;\n\n  constructor() {\n    super();\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(template.content.cloneNode(true));\n\n    this.srOnlyText = this.shadowRoot?.getElementById('sr-only');\n  }\n\n  connectedCallback() {\n    this.#uploaderEl = getMuxUploaderEl(this);\n\n    if (this.#uploaderEl) {\n      this.#uploaderEl.addEventListener('success', this.updateText.bind(this));\n    }\n  }\n\n  disconnectedCallback() {\n    if (this.#uploaderEl) {\n      this.#uploaderEl.removeEventListener('success', this.updateText.bind(this));\n    }\n  }\n\n  updateText() {\n    if (this.srOnlyText) {\n      this.srOnlyText.textContent = 'Upload complete!';\n    }\n  }\n}\n\nif (!globalThis.customElements.get('mux-uploader-sr-text')) {\n  globalThis.customElements.define('mux-uploader-sr-text', MuxUploaderSrTextElement);\n}\n\nexport default MuxUploaderSrTextElement;\n", "export * as constants from './constants';\nimport MuxUploaderElement, { MuxUploaderElementEventMap } from './mux-uploader';\nimport MuxUploaderProgressElement from './mux-uploader-progress';\nimport MuxUploaderDropElement from './mux-uploader-drop';\nimport MuxUploaderFileSelectElement from './mux-uploader-file-select';\nimport MuxUploaderRetryElement from './mux-uploader-retry';\nimport MuxUploaderSrTextElement from './mux-uploader-sr-text';\nimport MuxUploaderStatusElement from './mux-uploader-status';\nimport MuxUploaderPauseElement from './mux-uploader-pause';\n\nexport {\n  MuxUploaderDropElement,\n  MuxUploaderProgressElement,\n  MuxUploaderFileSelectElement,\n  MuxUploaderRetryElement,\n  MuxUploaderSrTextElement,\n  MuxUploaderStatusElement,\n  MuxUploaderPauseElement,\n};\nexport type { MuxUploaderElementEventMap };\nexport default MuxUploaderElement;\n"],
  "mappings": "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",
  "names": ["constants_exports", "__export", "ProgressTypes", "EventTarget", "_event", "DocumentFragment", "HTMLElement", "HTMLVideoElement", "customElements", "_name", "_constructor", "_options", "_root", "_detail", "CustomEvent", "_typeArg", "eventInitDict", "__privateAdd", "__privateSet", "__privateGet", "createElement", "_tagName", "globalThisShim", "isServer", "internalGlobalThis", "internalDocument", "require_window", "__commonJS", "exports", "module", "win", "require_is_function", "isFunction", "toString", "fn", "string", "require_parse_headers", "trim", "isArray", "arg", "headers", "result", "headersArr", "i", "row", "index", "key", "value", "require_immutable", "extend", "hasOwnProperty", "target", "source", "require_xhr", "window2", "parseHeaders", "xtend", "createXHR", "noop", "forEachArray", "method", "uri", "options", "callback", "initParams", "_createXHR", "array", "iterator", "isEmpty", "obj", "params", "called", "err", "response", "body2", "readystatechange", "xhr2", "loadFunc", "getBody", "getXml", "isJson", "errorFunc", "evt", "timeoutTimer", "failureResponse", "aborted", "status", "body", "sync", "e", "firefoxBugTakenEffect", "condition", "message", "args", "format", "anyToString", "x", "currentErrorHandler", "maybeError", "error", "Global", "currentWarnHandler", "Warning", "code", "stack", "_a", "InitEventWasCalledWhileDispatching", "FalsyWasAssignedToCancelBubble", "TruthyWasAssignedToReturnValue", "NonCancelableEventWasCanceled", "CanceledInPassiveListener", "EventListenerWasDuplicated", "OptionWasIgnored", "InvalidEventListener", "InvalidAttributeHandler", "Event", "NONE", "CAPTURING_PHASE", "AT_TARGET", "BUBBLING_PHASE", "type", "eventInitDict", "opts", "internalDataMap", "$", "currentTarget", "data", "setCancelFlag", "bubbles", "cancelable", "event", "name", "retv", "assertType", "keys", "DOMException", "DOMException2", "msg", "defineErrorCodeProperties", "ErrorCodeMap", "keys2", "EventWrapper", "getWrapperClassOf", "internalDataMap$1", "defineRedirectDescriptor", "original", "$$1", "wrapperClassCache", "originalEvent", "prototype", "wrapper", "defineWrapper", "BaseEventWrapper", "originalPrototype", "CustomEventWrapper", "d", "capture", "passive", "once", "signal", "signalListener", "listener", "thrownError", "reportError", "listeners", "isCapture", "list", "removeListener", "createListener", "findIndexOfListener", "removeListenerAt", "disableCow", "setRemoved", "_", "listenerMap", "EventTarget", "internalDataMap$2", "createListenerListMap", "type0", "callback0", "options0", "$$2", "normalizeAddOptions", "ensureListenerList", "warnDuplicate", "addListener", "normalizeOptions", "eventData", "createInvalidStateError", "cow", "isRemoved", "isOnce", "isPassive", "invokeCallback", "assertCallback", "keys$1", "import_xhr", "__toESM", "DEFAULT_CHUNK_SIZE", "DEFAULT_MAX_CHUNK_SIZE", "DEFAULT_MIN_CHUNK_SIZE", "isValidChunkSize", "chunkSize", "minChunkSize", "maxChunkSize", "getChunkSizeError", "ChunkedStreamIterable", "readableStream", "_b", "_c", "chunk", "reader", "done", "outgoingChunk", "normalizedBlobChunk", "ChunkedFileIterable", "file", "nextChunkRangeStart", "getChunk", "resolve", "length", "nextChunk", "SUCCESSFUL_CHUNK_UPLOAD_CODES", "TEMPORARY_ERROR_CODES", "RESUME_INCOMPLETE_CODES", "isSuccessfulChunkUpload", "res", "_options", "isRetriableChunkUpload", "retryCodes", "isFailedChunkUpload", "isIncompleteChunkUploadNeedingRetry", "range", "UpChunk", "readableStreamErrorCallback", "eventName", "detail", "beforeSend", "xhrObject", "remainingChunks", "percentagePerChunk", "chunkPercentage", "reject", "resp", "rangeStart", "rangeEnd", "successfulChunkUploadCb", "res2", "_chunk", "lastChunkInterval", "unevenChunkSize", "failedChunkUploadCb", "retriableChunkUploadCb", "chunkUploadSuccess", "closestComposedNode", "childNode", "selector", "closest", "getMuxUploaderEl", "controlEl", "muxUploaderId", "template", "internalDocument", "Attributes", "_overlayTextEl", "_uploaderEl", "_abortController", "MuxUploaderDropElement", "internalGlobalThis", "__privateAdd", "shadowRoot", "__privateSet", "getMuxUploaderEl", "__privateGet", "opts", "_a", "attributeName", "oldValue", "newValue", "evt", "dataTransfer", "files", "file", "mux_uploader_drop_default", "formatProgress", "percent", "template", "internalDocument", "ariaDescription", "_uploaderEl", "_abortController", "MuxUploaderProgressElement", "internalGlobalThis", "_a", "_b", "_c", "_d", "__privateAdd", "e", "percent", "ProgressTypes", "offset", "formatProgress", "__privateSet", "getMuxUploaderEl", "__privateGet", "opts", "currentType", "mux_uploader_progress_default", "template", "internalDocument", "_uploaderEl", "_abortController", "MuxUploaderStatusElement", "internalGlobalThis", "_a", "__privateAdd", "e", "successMessage", "offlineMessage", "__privateSet", "getMuxUploaderEl", "__privateGet", "opts", "mux_uploader_status_default", "template", "internalDocument", "_uploaderEl", "_abortController", "MuxUploaderRetryElement", "internalGlobalThis", "_a", "__privateAdd", "e", "ButtonPressedKeys", "key", "__privateGet", "_b", "__privateSet", "getMuxUploaderEl", "opts", "mux_uploader_retry_default", "template", "internalDocument", "_uploaderEl", "_abortController", "MuxUploaderPauseElement", "internalGlobalThis", "__privateAdd", "__privateGet", "__privateSet", "getMuxUploaderEl", "opts", "_a", "nextPausedState", "mux_uploader_pause_default", "fileSelectFragment", "template", "internalDocument", "_filePickerEl", "_uploaderEl", "_abortController", "MuxUploaderFileSelectElement", "internalGlobalThis", "_a", "_b", "_c", "__privateAdd", "e", "slot", "el", "__privateSet", "getMuxUploaderEl", "__privateGet", "opts", "value", "attr", "controller", "mux_uploader_file_select_default", "conditionalRender", "flag", "component", "attributeRender", "name", "value", "valueStr", "blockLayout", "contextElement", "noDrop", "noProgress", "noStatus", "noRetry", "pausable", "type", "wrapper", "progressElements", "statusElement", "retryElement", "pauseElement", "internalDocument", "fileSelectFragment", "rootTemplate", "internalDocument", "MuxUploaderElement", "internalGlobalThis", "_a", "_b", "file", "value", "val", "maxFileSize", "chunkSize", "boolVal", "oldLayout", "newLayout", "blockLayout", "message", "evt", "endpoint", "dynamicChunkSize", "upload", "UpChunk", "event", "err", "mux_uploader_default", "template", "internalDocument", "_uploaderEl", "MuxUploaderSrTextElement", "internalGlobalThis", "_a", "__privateAdd", "__privateSet", "getMuxUploaderEl", "__privateGet", "mux_uploader_sr_text_default", "index_default", "mux_uploader_default"]
}
